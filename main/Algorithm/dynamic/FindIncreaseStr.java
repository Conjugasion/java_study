package Algorithm.dynamic;

import java.util.ArrayList;
import java.util.Arrays;

/**
 * @author Lucas
 * @date 2019/7/30 21:23
 * 已知一个未排序的数组，求这个数组的所有上升子串(个数大于5)
 * 例如1,2,3,4,5,6,7,8,1,2,3,4,5,6, 最长子串为1,2,3,4
 */
public class FindIncreaseStr {
    public static void main(String[] args) {
        double[] str = {2.8,11.8,13.9,14.7,13.0,13.3,12.5,9.9,9.4,10.2,11.2,12.5,13.6,10.9,12.0,10.2,12.1,10.2,9.4,10.3,10.1,9.9,13.1,13.0,10.5,10.9,11.0,11.5,11.4,10.6,10.7,11.2,11.3,11.7,11.4,11.3,10.9,10.9,10.8,11.3,11.6,11.6,11.7,11.7,11.4,11.3,11.3,11.3,11.3,11.3,11.3,11.2,11.3,11.4,11.4,10.9,10.7,10.8,11.0,10.0,10.5,10.7,10.9,10.9,10.0,10.8,10.8,10.6,10.6,10.6,10.5,10.3,10.4,10.3,10.2,9.9,9.9,10.2,10.0,10.3,10.3,10.3,10.4,10.3,10.4,10.5,10.4,10.2,10.3,10.2,10.3,10.2,10.2,10.0,10.0,10.0,10.0,10.0,9.0,1.0,9.8,10.0,9.9,9.0,10.0,10.0,10.0,10.0,10.0,10.0,10.0,11.0,10.9,10.8,10.7,10.9,10.8,11.6,11.0,10.9,11.0,10.3,10.2,10.6,10.8,11.0,11.0,11.0,12.3,12.3,12.0,12.2,12.3,12.0,12.3,12.0,12.0,12.0,12.0,13.0,13.0,13.0,13.1,13.0,13.3,13.0,13.0,13.0,13.0,13.0,13.0,13.0,13.0,13.0,13.0,13.0,13.1,13.2,13.1,13.0,12.9,12.0,12.8,12.9,12.7,12.6,12.5,12.6,12.6,12.6,12.6,12.4,12.3,12.3,12.3,12.3,12.4,12.4,12.3,12.4,12.2,12.3,12.3,12.3,12.3,12.2,12.1,12.0,12.0,11.8,11.7,11.4,11.2,11.2,11.0,11.0,10.9,11.1,11.0,11.0,11.0,10.9,10.8,10.4,10.4,10.4,10.1,10.3,10.3,10.3,10.0,10.2,10.5,10.3,10.2,10.3,10.2,10.4,10.4,10.3,10.2,10.3,10.2,10.5,10.5,10.4,10.5,10.6,10.5,10.6,10.6,10.7,10.7,10.7,10.7,10.7,10.9,10.9,10.9,10.6,10.9,10.7,10.6,10.8,10.9,10.9,11.1,11.0,11.0,11.1,11.1,11.2,11.1,11.4,11.2,11.3,11.3,11.2,11.2,11.3,11.2,11.2,11.2,11.2,11.1,11.1,11.0,10.9,10.8,10.8,10.8,10.8,10.9,10.9,10.8,10.9,10.7,10.7,10.8,10.7,10.5,10.4,10.5,10.4,10.4,10.3,10.3,10.2,10.2,10.3,10.5,10.4,10.4,10.4,10.5,10.5,10.4,10.5,10.6,10.4,10.5,10.5,10.5,10.5,10.6,10.7,10.6,10.5,10.6,10.6,10.6,10.6,10.7,10.7,10.7,10.6,10.7,10.6,10.6,10.6,10.6,10.5,10.6,10.7,10.7,10.9,10.8,10.9,10.8,10.7,10.7,10.8,10.9,10.9,10.9,10.9,10.9,10.9,10.7,10.7,10.7,10.7,10.5,10.5,10.5,10.4,10.3,10.2,10.0,9.9,9.8,9.7,9.7,9.7,9.7,9.6,9.7,9.7,9.7,9.7,9.8,9.8,9.9,9.8,9.9,10.0,10.0,10.0,10.3,10.4,10.4,10.4,10.3,10.4,10.6,10.7,10.7,10.9,11.1,11.3,11.5,10.9,11.7,11.0,11.6,11.8,12.0,11.9,12.1,12.1,12.1,12.2,12.1,11.2,11.8,11.7,12.0,11.9,12.1,11.9,11.9,11.8,11.7,11.9,12.3,12.3,12.3,12.3,12.2,12.4,12.5,12.4,12.4,12.4,12.4,12.4,12.4,12.5,12.5,12.5,15.5,15.5,15.6,15.6,15.7,15.9,16.2,16.0,16.3,16.7,16.8,17.1,17.2,17.5,17.4,17.4,17.4,16.5,16.1,16.3,15.8,15.4,13.7,13.7,13.6,13.6,13.4,13.5,12.4,13.6,13.3,12.6,12.3,12.5,12.6,12.6,12.6,12.6,12.4,12.0,12.1,11.6,11.4,11.2,11.4,11.3,11.1,11.2,10.9,10.6,10.4,10.2,9.5,9.4,9.2,9.1,9.1,9.0,9.0,8.7,8.8,8.7,8.6,8.5,8.9,9.1,9.3,9.3,9.3,9.5,9.8,9.7,9.6,3.5,2.3,0.9,0.7,0.7,0.8,3.4,8.6,8.7,8.9,9.3,9.3,9.3,9.4,9.4,9.4,9.4,9.5,9.0,9.3,9.3,9.2,8.7,8.5,8.7,8.6,7.8,3.2,2.2,1.8,1.6,1.3,1.1,5.5,9.4,7.7,11.2,11.3,10.1,9.8,5.8,10.0,12.0,10.0,10.0,5.2,3.2,1.7,0.2,0.0,0.0,0.1,0.1,0.0,0.1};
        find(str);

    }

    // dp[i]表示以第i个数字结尾的 最长上升子串
    // dp[i] = dp[i-1]+1, 如果str[i]>=str[i-1],否则dp[i] = 1
    static void find(double[] str){
        int[] dp = new int[str.length];
        dp[0] = 1;
        int max = 0;
        for (int i = 1; i < str.length; i++) {
            if (str[i]>=str[i-1]){
                max = Math.max(max, dp[i-1] + 1);
                dp[i] = dp[i-1] + 1;
            } else {
                dp[i] = 1;
            }
        }

        //System.out.println(Arrays.toString(dp));

        ArrayList<double[]> result = new ArrayList<>();
        for (int i = 1; i < dp.length; i++) {
            if (dp[i] <= dp[i-1] && dp[i-1] >= 5) {
                result.add(Arrays.copyOfRange(str, i-dp[i-1], i));
            }
            if (i == dp.length-1 && dp[i] >= 5) {
                result.add(Arrays.copyOfRange(str, i+1-dp[i], i+1));
            }
        }
        for (double[] r:result) {
            System.out.println(Arrays.toString(r));
        }
    }
}
