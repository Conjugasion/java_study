JAVA基础

JAVA中的几种基本数据类型是什么，各自占用多少字节。
boolean 1b, byte 1b, char 2b, short 2b, int 4b, long 8b, float 4b, double 8b


String类能被继承吗，为什么。
不能，final修饰


String，Stringbuffer，StringBuilder的区别。
不可变类， 可变线程安全，  可变线程不安全


ArrayList和LinkedList有什么区别。
数组实现，扩容时拷贝，查找方便；链表实现，增删方便


讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字 
段，当new的时候，他们的执行顺序。
父类静态数据 and 父类静态代码块 > 子类静态数据 and 子类静态代码块 > 父类普通变量、非静态代码块、构造方法 > 子类普通变量、非静态代码块、构造方法


用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
hashtable             hashmap                 linkedhashmap                treemap
线程安全           线程不安全效率高          线程不安全插入顺序即存储顺序  可以按照指定顺序存储数据，自动排序
 哈希表               哈希表                  hashmap+双向链表记录顺序         红黑树
hashmap/linkedhashmap冲突个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)
存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，treemap的key不允许null，value允许null；              
Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模
HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模
HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75
HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1
HashMap是非线程安全的,只是用于单线程环境下,多线程环境下可以采用concurrent并发包下的concurrentHashMap。HashTable是线程安全的,synchronized
HashMap/linkedhashmap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。
HashTable在 key、value 遇到null时，会抛出NullPointerException异常
HashMap仅支持Iterator的遍历方式，Hashtable支持Iterator和Enumeration两种遍历方式

				 
JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
1.7 ConcurrentHashMap加锁粒度是基于Segment（ReentrantLock）的，包含多个HashEntry。多个线程同时竞争获取同一个segment锁，获取成功的线程更新
map；失败的线程尝试多次获取锁仍未成功，则挂起线程，等待释放锁
1.8 ConcurrentHashMap加锁粒度是基于HashEntry，采用Synchronized和CAS，锁粒度变小了。当bucket为空时，使用CAS操作，将Node放入对应的bucket中当出现hash冲突时，则采用synchronized关键字。链表超过一定长度会转成红黑树。


有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
linkedhashmap： hashmap+双向链表记录顺序
treemap： 自定义排序，自动维护顺序， 红黑树


抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
接口方法默认public static，接口变量默认public staic final，方法一般是不能实现的；抽象类可以有抽象方法也可以具体方法。
类不可以继承多个类，但是可以实现多个接口，接口可以继承多个接口。


IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。
同步阻塞的BIO，面向流，都是inputstream和outputstream，服务端启动一个severSocket监听特定端口，然后客户端创建指定ip地址和端口的socket去连接服务器。每有一个客户端连接进来，服务器都要创建一个线程，当有大量客户端连接时，服务器会不堪重负。
同步非阻塞的NIO，面向缓存，从channel读到buffer，从buffer写到channel。事件驱动型，Reactor设计模式，socket会注册感兴趣的事件，少量线程负责轮询socket，当感兴趣的事件准备好的时候，再创建一个线程去处理。但是具体的IO读写还是阻塞的。
异步非阻塞AIO，Proactor设计模式，不用用户线程亲自读写，OS会把可读的流传入read方法缓冲区，write方法的写入完毕时会通知用户线程。


反射的原理，反射创建类实例的三种方式是什么。
根据类名找到对应的.class文件，通过字节码文件进行一系列操作
Class clazz = Class.forname()；
Class clazz = 实例.getClass()；
Class clazz = 类.class


反射中，Class.forName和ClassLoader区别 。
JVM加载class有三个步骤：加载，链接(检查、准备、解析)，初始化
Class.forname()得到的class对象是已经初始化完毕的。
ClassLoader得到的class对象还没有链接，仅仅加载了而已，不会执行static中的内容,只有在newInstance才会去执行static块。


描述动态代理的几种实现方式，分别说出相应的优缺点。
1. 原生JDK方式。代理类和目标类实现同一接口，代理类持有目标类对象来达到拦截的目的。必须借助接口才能产生代理对象，只有在接口中声明的方法，代理类才能进行拦截。
2. CGLIB，底层使用ASM在内存中动态生成被代理类的子类，即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB简单易用，它的运行速度要远远快于JDK的Proxy动态代理
3. asm
4. javassist


动态代理与cglib实现的区别。
1.原生JDK方式。代理类和目标类实现同一接口，代理类持有目标类对象，来达到拦截的目的。必须借助接口才能产生代理对象，只有在接口中声明的方法，代理类才能进行拦截。
2.CGLIB，底层使用ASM在内存中动态生成被代理类的子类，即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB简单易用，它的运行速度要远远快于JDK的Proxy动态代理


为什么CGlib方式可以对接口实现代理。
CGLIB，底层使用ASM在内存中动态生成被代理类的子类，即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB简单易用，它的运行速度要远远快于JDK的Proxy动态代理


final的用途。
1.final修饰类，类不能被继承
2.final修饰基本类型变量，变量的值不能修改
3.final修饰引用变量，变量不能被指向其它对象
4.final修饰方法，方法不能被重写，但是能被重载


写出三种单例模式实现 。
1.饿汉式
public class Singleton{
	private staic Singleton instance = new Singleton();
	private Singleton(){
		System.out.println("构造方法");
	}
	public Singleton getSingleton(){
		return instance;
	}
}
tips:调用外部类的静态变量和静态方法，不会初始化静态内部类
2.public class Singleton{
	private Singleton(){
		System.out.println("构造方法");
	}
	private static class InnerSingleton{
		private final staic Singleton instance = new Singleton(); 
	}
	public Singleton getSingleton(){
		return InnerSingleton.instance;
	}
}
加同步锁，前后两次判断
3.public class Singleton{
	private Singleton instance = null;
	private Singleton{
		System.out.println("构造方法");
	}
	public Singleton getSingleton(){
		if (instance==null) {
			synchronized(Singleton.class){
				if (instance==null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}


请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
public 对所有人都开放，private 仅对本类成员开放， protected 对本类、子类、本包开放， default 对本类和本包开放


深拷贝和浅拷贝区别。
浅拷贝：源本和副本共享相同的引用类型对象，基本类型是各自一份的，所以修改引用类型会引起源本和副本的同时变化，修改基本类型不会引起同时变化。
深拷贝：源本和副本引用类型和基本类型都是各自一份，所以修改只会影响自己。
Object.clone()实现浅拷贝，若要实现深拷贝，需要将对象引用到的所有类都 implement Cloneable 接口(重写clone方法)，比较麻烦
可以采用序列化的方法实现简单深拷贝，需要将对象引用到的所有类都 implements Serializable 接口(不需要重写方法)
transient 和 static 修饰的属性不能被序列化


error和exception的区别，CheckedException，RuntimeException的区别。
error 表示虚拟机发生了严重错误，必须修改程序。
exception 表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。
CheckedException 受查异常/编译时异常 编写代码的时候必须考虑到的异常，可以 throws 或者 try-catch。
RuntimeException 非受查异常/运行时异常 不需要捕获，一旦抛出 RuntimeException 异常，请修改程序。


请列出5个运行时异常。
空指针异常 NullPointerException 
类找不到异常 ClassNotFoundException 
算数异常 ArithmeticException
数组越界异常 ArrayIndexOutOfBoundsException
类型转换异常 ClassCastException


在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么？
不可以，因为存在双亲委派模型模型。先交给 bootStrap ClassLoader，若无法加载在交给 extension ClassLoader，若还不能加载则交给 System ClassLoader
通过双亲委托模式传递到引导加载器，而引导加载器在核心 Java API 发现这个名字的类，所以会加载该核心类，并不会加载自己写 java.lang.String类。
这样便可以防止核心API库被随意篡改。
public class String {
    public static void main(String[] args) {
        String str = "my String";
        System.out.println(str);
    }
}
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application

如果我们在 classpath 路径下自定义一个名为 java.lang.MyString 类(该类是胡编的)呢？该类并不存在 java.lang中，经过双亲委托模式，传递到启动类加载器中，
由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过 System 加载器加载该类。
但是这样做是不允许，因为 java.lang 是核心API包，需要访问权限，强制加载将会报出如下异常：
java.lang.SecurityException: Prohibited package name: java.lang


说一说你对java.lang.Object对象中 hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。
两个对象属性相同应当认为这两个对象是相同的，而不能简单的去比较两个对象的内存地址是否相同。equals 比较的是两个对象的属性，若 equals返回true，
两个对象的hashcode必须相等；若两个对象的 hashcode相等，equals不一定为true。
需要根据对象属性去判断两个对象是否相等的场景需要重写 hashcode 和 equals


在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
泛型的主要目标是实现 java 的类型安全。 泛型可以使编译器知道一个对象的限定类型是什么，从而检查是否有代码错误。
消除了强制类型转换 使得代码可读性好，减少了很多出错的机会


这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。
默认调用 object 的hashcode方法，用于计算对象的内存地址。equals在不重写的情况下，使用的是object默认的 equals，调用==比较的也是对象的内存地址。


有没有可能2个不相等的对象有相同的hashcode。
可能，hash冲突


Java中的HashSet内部是如何工作的。
hashSet基于hashMap实现，因为 hashMap 的 key 是不能重复的，value 是统一的 public final static Object PRESENT = new Object()。
往 HashSet 中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样 HashSet 中就不存在重复值。


什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
将 JVM 中的对象持久化保存到磁盘，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。
FileOutputStream fs = new FileOutputStream();
ObjectOutputSream os = new ObjectOutputSream(fs);
os.writeObject(对象);
os.close();
序列化的作用就是为了不同 jvm 之间共享实例对象;内存中的对象状态保存到一个文件中或者数据库中时候；当你想用套接字在网络上传送对象的时候；当你想通过RMI传输对象的时候；
transient 和 static 修饰的变量不参与序列化
serialVersionUID 不要去改动


java8的新特性。
Lambda 表达式，Stream API，接口默认方法


什么情况下会发生栈内存溢出。
递归太深


JVM的内存结构，Eden和Survivor比例。
8:1:1


JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
持久带存放字符串常量池、类的基本信息，默认大小 4m，Jdk8 已经直接取消了 Perm 区域，新建了一个分配在本地内存的元空间。
因为新生代采用复制算法，Eden和to的存活对象复制到from，然后删除Eden和to中的对象，最后from和to互换。


JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
-XX:+printGC(打印GC)；-XX:+PrintGCDetails；(打印GC细节)-XX:+PrintHeapAtGC；(在GC时打印堆状况)-XX:+TraceClassLoading；(打印class加载细节)
-Xmx（最大堆的空间)；-Xms（最小堆的空间）; -Xmn (设置新生代的大小)；-XX:NewRatio(新生代和老年代比例)；-XX:SurvivorRatio；-Xss（设置栈空间的大小）;
-XX:+HeapDumpOnOutOfMemoryError；


你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
新生代垃圾收集器： Serial，采用复制算法，单线程，在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				ParNew，Serial 的多线程版，采用复制算法，在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				Parallel Scavenge，多线程，采用复制算法，吞吐量优先,运行代码时间/(运行代码时间+垃圾收集时间)，最高效率地利用CPU时间，
				尽快地完成程序的运算任务,在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				G1......

老年代垃圾收集器： Serial Old，采用标记-整理算法，单线程，在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				Parallel Old,采用标记-整理算法，多线程，吞吐量优先,在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				CMS 采用标记-清除算法，多线程，主要目标是获取最短垃圾回收停顿时间，真正意义上并发垃圾收集器，它第一次实现了让垃圾收集线程和用户线程同时工作。
				G1 基于标记-整理算法，高垃圾收集效率。可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
				G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，
				同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。


垃圾回收算法的实现原理。
标记清除算法；标记整理算法；复制算法；分代收集算法
GC Root：栈中的对象


当出现了内存溢出，你怎么排错。
-XX:+HeapDumpOnOutOfMemoryError，Mat分析堆转储文件


JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
重排序指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。
对于有数据依赖的代码，不会重排序，比如写后读、写后写和读后写，as-if-serial；
happen-before是指A 操作 happen-before B 操作，只要保证结果正确，具体指令按什么顺序执行时可以重排序的。
as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

内存屏障
Store：将cache的数据刷新到内存中。Load：将内存存储的数据拷贝到cache中。
四种屏障：loadload、storestore、loadstore、storeload


简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
bootStrap ClassLoader、extension ClassLoader 和 System ClassLoader
首先自己写一个加载器继承 ClassLoader，重写loadClass和findClass方法
两个类是否相同，需要他们的加载器相同！ 所以即使自己自定义加载器加载自己写的java.lang.String，系统也不认为该类就是真正的String


讲讲JAVA的反射机制。
反射就是对.class文件(字节码)进行一系列操作，包括获取所有变量、属性、方法、构造器...


g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
CMS 是多线程老年代垃圾回收器，基于标记-清除算法，是真正意义上的并发垃圾收集器，追求最短的垃圾回收停顿时间。大概分为四步，首先初始标记(stop the world)，
标记出root可达的对象，然后并发标记，跟踪可达对象，再标记可达对象，接着重新标记(stop the world)，标记可达对象，最后并发清理。缺点是占用cpu，清理不彻底。
G1 基于对于新生代采用复制算法，对于老年代采用标记-整理算法，高垃圾收集效率。可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
G1 垃圾收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，
每次根据所允许的收集时间，优先回收垃圾最多的区域。


怎么打出线程栈信息。
jstack


请解释如下jvm参数的含义： 
-server -Xms512m -Xmx512m -Xss1024K 
server: 指java启用JIT的Server Compiler，全局优化，优化比较慢，client Compiler 仅采用局部优化，优化比较快。
java堆最小512M，最大512M，栈空间大小1024K
-XX:PermSize=256m -XX:MaxPermSize=512m
永久代大小初始256m，最大512m
-XX:MaxTenuringThreshold=20
新生代晋升老年代的年龄阈值，默认15； 
-XX:MSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly。
当内存被占用达到80%时，启动full GC；指定cms使用手动设定的阈值full GC，否则只有第一次会在80%时GC，之后则自动调整


操作系统

Linux系统下你关注过哪些内核参数，说说你知道的。
fs.file-max 和 ulimit: 前者是指整个系统最大能打开的文件描述符的数量，后者指某个进程最大能打开的文件描述符的数量。

net.ipv4.tcp_fin_timeout = 2           #保持在FIN-WAIT-2状态的时间，使系统可以处理更多的连接。此参数值为整数，单位为秒。
net.ipv4.tcp_max_tw_buckets = 5000     #系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数值将立刻被清楚并输出警告信息。默认值为180000。对于squid来说效果不是很大，但可以控制TIME_WAIT套接字最大值，避免squid服务器被拖死。 
net.ipv4.tcp_tw_reuse = 1              #开启重用，允许将TIME_WAIT socket用于新的TCP连接。默认为0，表示关闭。
net.ipv4.tcp_tw_recycle = 1            #开启TCP连接中TIME_WAIT socket的快速回收。默认值为0，表示关闭。

net.ipv4.tcp_max_syn_backlog = 262144  #表示SYN队列的长度，预设为1024，这里设置队列长度为262144，以容纳更多的等待连接。
net.ipv4.tcp_syncookies = 1            #开启SYN cookie，出现SYN等待队列溢出时启用cookie处理，防范少量的SYN攻击。默认为0，表示关闭。
net.core.somaxconn = 16384             #定义了系统中Accept队列长度, 即完成三次握手的连接数量，对于一个经常处理新连接的高负载web服务环境来说，默认值为128，偏小。

net.ipv4.tcp_keepalive_time = 600      #keepalived启用时TCP发送keepalived消息的频度。
net.ipv4.tcp_keepalive_probes = 5      #TCP发送keepalive探测以确定该连接已经断开的次数。根据情形也可以适当地缩短此值。
net.ipv4.tcp_keepalive_intvl = 15      #探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒。对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值。
net.ipv4.ip_local_port_range = 1024 65000 #指定外部连接的端口范围。默认值为32768 61000。
net.ipv4.tcp_max_orphans = 16384       #表示系统中最多有多少TCP套接字不被关联到任何一个用户文件句柄上。如果超过这里设置的数字，连接就会复位并输出警告信息。这个限制仅仅是为了防止简单的DoS攻击。此值不能太小。 


Linux下IO模型有几种，各自的含义是什么。
阻塞IO：传统IO                                                                        
非阻塞IO：用户线程不断轮询内核数据是否准备好了，长期占用cpu。          
多路复用IO：Reactor模式，由单个内核线程不断轮询多个socket channel状态。
信号驱动型IO：每个socket注册一个信号函数，当数据就绪时会发送一个信号给用户线程，然后用户线程进行IO读写。				   				   
异步IO：用户线程发起IO请求，立刻就可以去做自己的事情。用户线程和内核线程通过mmap映射同一块内存区域，内核会等待数据准备完成，然后将数据读取到共享内存。最后告知用户线程IO操作已经完成，可以直接使用数据了。                   


epoll和poll有什么区别。
poll:和select没啥区别。采用遍历fd的方式获取已经就绪的socket。因为是基于链表存储，所以没有监视文件描述符的数量限制。
	 仅支持水平触发模式，如果报告的fd没有被处理，下次轮询还是会报告该fd。
epoll:linux特有，支持水平触发和边缘触发；边缘触发:仅会通知一次fd就绪的消息，若没有处理，下次也不会通知了。
	 使用”事件“就绪通知方式，使用epoll_ctl注册fd，一旦该fd就绪，内核会调用callback回调机制激活fd，epoll_wait会收到通知。
	 没有并发连接限制(1G -> 10W连接)，不采用轮询方式。epoll采用mmap技术。
	 如果没有大量空闲连接，epoll效率和poll/select差不多


用一行命令查看文件的最后五行。
tail -n 5 filename
用一行命令查看文件的开头五行。
head -n 5 filename
查看文件的第三行到第五行
cat filename | tail -n +3 | head -n 5
将标准输出流和错误输出流都重定向到log
ls filename > log 2>&1


用一行命令输出正在运行的java进程。
jps


介绍下你理解的操作系统中线程切换过程。
线程切换不需要切换内存映射表，只需要切换指令。
用户级线程切换，切换栈即可；核心级线程切换，需要切换一套栈，核心栈和用户栈


top 命令之后有哪些内容，有什么作用。
进程号、进程所有者、进程名，ni静态优先级-20~19，越低优先级越高，pr动态优先级，virt进程使用的虚拟内存总量，shr共享内存大小，res进程使用的未被换出的物理内存大小
S进程状态， %CPU CPU使用率，%MEM 内存使用率，TIME 进程使用时间


source、sh、bash和.运行脚本有什么区别
./jiaoben.sh 需要脚本有执行权限，source、sh和bash不需要脚本有执行权限；source和.是在当前shell内执行脚本，同一个进程号，而sh和bash是另起一个进程执行脚本


僵尸进程和孤儿进程
僵尸进程:父进程还在运行，子进程却挂了，父进程没有使用wait来清理子进程信息，导致系统中还保留着一些子进程信息，浪费系统资源
孤儿进程:子进程还在运行，父进程却挂了，子进程会交给init进程统一管理，完成状态收集工作


linux下进程的五种状态
就绪状态，运行状态，中止状态，
可中断睡眠状态:进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。
不可中断睡眠状态:进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。
僵死状态:僵尸进程，虽然线程已死亡，但是系统中还残留部分信息


多线程

多线程的几种实现方式，什么是线程安全。
继承Thread类、实现Runnable借口、实现Callable接口


volatile的原理，作用，能代替锁么。
不能代替锁。被volatile修饰的变量每次都从主存中读取，并且禁止指令重排序。volatile变量是一种比sychronized关键字更轻量级的同步机制


画一个线程的生命周期状态图。
就绪状态，运行状态，阻塞状态，中止状态
中止状态:程序正常执行完毕、调用stop(会释放锁)
阻塞状态:比如调用sleep(不会释放锁),阻塞式IO读写，没有获得监视器，wait(释放锁)某个notify()，调用suspend(不会释放锁)，yield(不会释放锁)


sleep和wait的区别。
sleep不会释放锁，wait会释放锁


sleep和sleep(0)的区别。
sleep(long time) 线程在指定时间内不参与cpu竞争；sleep(0) 线程会从阻塞队列直接回到就绪队列，参与cpu竞争，是想让其他线程也有得到cpu运行的机会，


Lock与Synchronized的区别 。
Synchronized是内置锁，处于jvm层面，Lock是java类；
Synchronized无法判断是否获取锁，Lock可以判断是否获取到锁；
Synchronized会自动释放锁，Lock需在finally中手工释放锁；
Synchronized会导致无法获得锁的线程一直等待，Lock可以tryLock(time)，若还不能获得锁则执行别的逻辑
Synchronized可重入、不可中断、非公平，Lock可重入、可中断、可公平、可不公平
Synchronized锁适合代码少量的同步问题，Lock锁适合大量同步的代码的同步问题。


synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)。
同步代码块是使用MonitorEnter和MoniterExit指令实现的，在编译时，MonitorEnter指令被插入到同步代码块的开始位置，MoniterExit指令被插入到同步代码块的结束位置和异常位置。
加在静态方法前锁定的是整个类，加在非静态方法前锁定的是当前对象。
修饰静态方法，锁是加在类上的，类的所有对象竞争一把锁;修饰非静态方法，锁加在单个对象上，不同对象间没有竞争关系。


解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。
重排序:编译器和处理器为了优化程序性能而对指令进行重新排序
自旋锁:为了编译线程上下文切换带来的损耗，所以让线程空等待
偏向锁:在没有实际竞争的情况下，自始至终都只有一个线程在使用锁，降低获取锁的消耗，仅要一次CAS操作
轻量级锁:无实际竞争，多个线程交替使用锁，允许短时间的锁竞争(自旋)
可重入锁:线程可以进入它拥有的锁所同步的代码块
公平锁:加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得
非公平锁:随机获得锁
乐观锁:假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。比如Synchronized
悲观锁:假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。比如CAS机制


用过哪些原子类，他们的原理是什么。
AtomicInteger、AtomicLong、AtomicBoolean，CAS


JUC下研究过哪些并发工具，讲讲原理。
CountDownLatch:使一个线程等待其他线程都执行完毕后才开始执行
CyclicBarrier:所有线程相互等待，只有当所有线程都到达某个点之后才能开始接着往下做
Semaphore:限制同一时刻访问某种资源的线程数量
Exchanger:交换器,两个线程到达同步点后交换数据


用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。
ThreadPoolExecutor(......)
corePoolSize核心线程数量，maxsize核心线程+非核心线程数量，keepAliveTime非核心线程最大闲置时间，timeUnit时间单位，workQueue等待队列
threadFactory工厂方法，Reject拒绝机制
几种常用的线程池
CachedThreadPool():new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>());
				   核心线程为0，核心线程数量几乎无限制，60秒限制销毁线程，等待队列为同步队列，出队和入队必须同时进行。
				   快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。
FixedThreadPool:new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
			    核心线程数为nThread，没有非核心线程，等待队列几乎无限制，可以存储大量任务。
			    可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。
SingleThreadPool:仅一个核心线程，一个一个的执行任务
ScheduledThreadPool:隔多久执行一个任务


线程池的关闭方式有几种，各自的区别是什么。
shutDownNow:线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。
shutDown:线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。
awaitTermination 和 shutDown 配合使用


假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。
ScheduledThreadPool + Semaphore


spring的controller是单例还是多例，怎么保证并发的安全。
Controller 默认情况下是单例模式


ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。
用于保存某个共享变量的副本，修改、删除不会影响别的线程。Thread类中有一个成员变量属于ThreadLocalMap类，一个定义在ThreadLocal类中的内部类
ThreadLocalMap<ThreadLocal，Object>成员变量，以ThreadLocal对象为key


如果让你实现一个并发安全的链表，你会怎么做。
ConcurrentLinkedQueue，Collections.synchronizedList()


有哪些无锁数据结构，他们实现的原理是什么。
CAS


讲讲java同步机制的wait和notify。
都是Object方法，只能在同步代码块中调用，wait释放锁、线程阻塞，notify唤醒等待在监视器上的线程，使之重新加入cpu竞争


CAS机制是什么，如何解决ABA问题。
AtomicStampedReference，加版本戳/时间戳


多线程如果线程挂住了怎么办。
因为wait挂住，需要等待notify/notifyAll才能进入可执行状态
因为sleep挂住，需要等待指定时间
因为join挂住，需要等待之前的线程都完成才能执行
因为suspend挂住，需要等待resume唤醒


countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的)。
CountDownLatch等待前面的线程都完成之后，后面的线程才能开始执行，递减，不可重复利用
CyclicBarrier线程相互等待，知道所有线程都完成任务到达屏障点，再一块往下执行，递加，可重复利用


对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同。
AQS定义两种资源共享方式:独占，只有一个线程能执行，如ReentrantLock；共享，多个线程可同时执行，如Semaphore。
AQS为Java中的并发同步组件提供统一的底层支持，关键点:同步状态和同步队列
state为0，说明当前锁已经被占，需要添加到同步队列中；state为1，说明线程可以获取到锁，共享锁state大于1
同步队列:它是一个双端队列，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果已经被占用，那么当前线程就会被构造成一个Node
	   节点插入到同步队列的尾部。队列的头节点是成功获取锁的节点，当独占锁的头节点线程释放锁时，会唤醒其直接后继节点并释放当前头节点的引用；当共享锁头
	   节点释放锁，会唤醒其后面的所有节点 


使用synchronized修饰静态方法和非静态方法有什么区别。
修饰静态方法，锁定的是这个类，修饰非静态方法锁定的是这个对象


简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
LinkedBlockingQueue 是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。 
ConcurrentLinkedQueue是一个基于链节点的无界线程安全队列，


导致线程死锁的原因？怎么解除线程死锁。
在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。
释放某个线程拥有的资源，


用过读写锁吗，原理是什么，一般在什么场景下用。
ReentrantReadWriteLock 适用读比写多的场景。基于AQS实现同步功能，将同步状态state掰成两份用，读与写互斥，支持重入，但是可以从写锁降级为读锁，反之不行


延迟队列的实现方式，delayQueue和时间轮算法的异同。
延迟一段时间后触发事件
delayQueue:采用PriorityQueue实现，二叉堆实现，在插入和获取时都是O(logn)
时间轮:一个轮子，有8个“槽”，可以代表未来的一个时间。如果以秒为单位，中间的指针每隔一秒钟转动到新的“槽”上面，就好像手表一样。如果当前指针指在1上面，
	  我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。采用数组或者环形链表实现。
DelayQueue由于涉及到排序，需要调堆，插入和移除的复杂度是O(lgn)，而时间轮在插入和移除的复杂度都是O(1)。


TCP与HTTP

http1.0和http1.1有什么区别。
缓存处理，1.1引入了更多的缓存控制策略；
带宽优化，1.1允许只请求资源的某个部分；
新增错误码，1.1新增了24个错误状态响应码；
Host 头处理，HTTP1.1的请求消息和响应消息都应支持Host头域，一台服务器上可能有多台虚拟服务器共享ip，所以需要请求需要带hostname
长连接，1.1默认开启keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。


TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
断开的时候，只有当服务器端所有的报文都发送完了，它才能发送FIN报文，因此不能一起发送。故需要四步握手。
如果只有两次握手，可能会导致服务器端建立一些实际不应该建立的连接。比如服务器接收到本来以为已经丢失的数据报，就会返回客户端一个syn和ack消息，如果仅需要
两次就建立连接，这明显是不正确的，但是如果是三次建立连接，服务端需要等待客户端的确认，客户端并不会发送ack，所以就不会建立连接。


TIME_WAIT和CLOSE_WAIT的区别。
TIME_WAIT位于客户端fin_wait1和fin_wait2之后，他需要等待2msl时长......
CLOSE_WAIT位于服务端接收到fin_wait1发来fin之后
TIME_WAIT状态用来重发可能丢失的ACK报文。 
TIME_WAIT表示主动关闭，CLOSE_WAIT表示被动关闭。


说说你知道的几种HTTP响应码，比如200, 302, 404。
200 ok 一切正常 
302 暂时性转移 重定向
404 页面未找到 

当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
请求dns服务器解析域名得到请求主机ip，发起tcp建立请求，然后发起http请求，服务器接收http请求并处理，服务器响应，返回html，浏览器对页面进行渲染，断开连接


TCP/IP如何保证可靠性，说说TCP头的结构。
源端口，目的端口，序列号，确认号，首部长度字段，六位标志位，窗口大小，校验和，紧急指针


如何避免浏览器缓存。
请求头中设置Cache-Control:max-age=0，告诉浏览器不要缓存信息
POST请求无法被缓存；动态请求是不能被缓存的


如何理解HTTP协议的无连接和无状态性。
无连接:请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。但是因为现在网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要
	  立一次 TCP 连接就显得很低效。Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免重新建立连接。
无状态:协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，
	  不会记录任何信息。但是当大量客户端与服务器进行动态交互的 Web 应用程序出现之后，引入了cookie和session。


简述Http请求get和post的区别以及数据包格式。
get请求将参数放置于url后面，post请求将参数放在请求体里，更安全；
get提交的数据最多1024字节，post能传输的数据量很大。


HTTP有哪些method
get、post、put、delete、head、options、trace、patch


简述HTTP请求的报文格式。
请求报文:请求行(请求方法、url、http版本)、请求头(一堆的键值对)、请求体(get方法没有请求体，post方法有请求体)
响应报文:响应行(http版本、状态码、状态码描述符)、响应头(一堆键值对)、响应体(服务器返回给客户端的文本信息)


HTTP的长连接是什么意思。
HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据
keepalived,不要断开连接，后续如果还有请求，直接在当前连接上请求。


HTTPS的加密方式是什么，讲讲整个加密解密流程。
HTTPS 443端口，HTTP+SSL/TLS
客户端发起https请求。
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。
传送证书给客户端，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
客户端解析证书，验证该证书是否有效，如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。
传送加密信息，让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把要传输的内容通过该值进行对称加密。除非知道私钥，不然无法获取内容。


Http和Https的三次握手有什么区别。
当浏览器使用https时，浏览器会先同SSL/TLS进行通信，然后SSL/TLS再同tcp进行通信


REST和RPC的区别
REST是面向资源的（URL表示资源，HTTP动词表示动作），RPC是面向动作的（方法调用）
RPC的编程模型较重量级，REST的编程模型更轻量级
RPC 自定义tcp+json 传输更轻量化， rest http报文会包含很多无用的信息，效率低
对外开放的api采用rest，内部通信采用rpc


Session和cookie的区别。
Session 存放在服务器端的客户端信息，通过sessionID进行标识，客户端每次访问都要带着这个id(通过cookie或者url重写)。会占用服务器性能
Cookie 服务端存放在客户端的信息，不是很安全


数据库知识

数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。
读未提交，读已提交/不可重复读，可重复读，串行化
mysql默认是可重复读


什么是幻读。
如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，
以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。


MYSQL有哪些存储引擎，各自优缺点。
myisam:拥有较高的插入，查询速度，但不支持事务,使用表级锁，并发性差,主机宕机后，MyISAM 表易损坏，灾难恢复性不佳 
innodb:5.5版本后Mysql的默认数据库，事务型数据库的首选引擎，支持ACID事务，支持行级锁定,灾难恢复性好


高并发下，如何做到安全的修改同一行数据。
使用悲观锁 悲观锁本质是当前只有一个线程执行操作，结束了唤醒其他线程进行处理。 
也可以缓存队列中锁定主键。
加锁分为显式加锁与隐式加锁，上面的写法是显式加锁。mysql在执行insert、update会自动加锁，mysql对select却不会加锁


乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。
乐观锁:认为修改不会发生冲突，只有在提交事务的时候才去检查，如果反正冲突则回滚
悲观锁:认为修改会引起冲突，所以一定要获得排它锁之后才能进行操作
共享锁和排它锁


SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。
show status 通过慢查询日志定位哪些是执行效率的sql语句
explain sql 显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句


数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。
事务A先修改表1后修改表2，事务2先修改表2后修改表1

系统资源不足
进程运行推进的顺序不合适 
资源分配不当等

重启数据库；杀死抢资源的进程


Mysql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
=和in可以乱序
尽量选择区分度高的列作为索引，尽量少重复
尽量的扩展索引，不要新建索引。


聚集索引和非聚集索引的区别。
聚簇索引就是索引和记录紧密在一起。 
非聚簇索引 索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块

select for update 是什么含义，会锁表还是锁行或是其他。
为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。


数据库的ACID是什么。
A，atomic，原子性，要么都提交，要么都失败，不能一部分成功，一部分失败。 
C，consistent，一致性，事物开始及结束后，数据的一致性约束没有被破坏 
I，isolation，隔离性，并发事物间相互不影响，互不干扰。 
D，durability,持久性，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。


某个表有近千万数据，CRUD比较慢，如何优化。


Mysql怎么优化table scan的。
避免在where子句中对字段进行is null判断 
应尽量避免在where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。 
避免在where 子句中使用or 来连接条件 
in 和not in 也要慎用 
Like查询（非左开头） 
使用NUM=@num参数这种 
where 子句中对字段进行表达式操作num/2=XX 
在where子句中对字段进行函数操作


如何写sql能够有效的使用到复合索引。
<、>、between放后面，先执行=

mysql中in 和exists 区别。
mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，
这种说法其实是不准确的。这个是要区分环境的。
如果查询的两个表大小相当，那么用in和exists差别不大。 
A B 两表，A in B 如果B较小，in不错，如果B很大，使用exists
not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。 
1.EXISTS只返回TRUE或FALSE，不会返回UNKNOWN。
2.IN当遇到包含NULL的情况，那么就会返回UNKNOWN。

数据库自增主键可能的问题。
自增主键会产生表锁；在分库分表时可能会生成重复主键


MVCC的含义，如何实现的。
你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。
MYSQL的主从延迟怎么解决。


算法

10亿个数字里里面找最小的10个。
有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。
2亿个随机生成的无序整数,找出中间大小的值。
给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。
遍历二叉树。
有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。
写一个字符串（如：www.javastack.cn）反转函数。
常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的 
优化方案。
二分查找的时间复杂度，优势。
一个已经构建好的TreeSet，怎么完成倒排序。
什么是B+树，B-树，列出实际的使用场景。
一个单向链表，删除倒数第N个数据。
200个有序的数组，每个数组里面100个元素，找出top20的元素。
单向链表，查找中间的那个元素。


消息队列

消息队列的使用场景。
消息的重发，补充策略。
如何保证消息的有序性。
用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务 
架构怎样的。
MQ系统的数据如何保证不丢失。
rabbitmq如何实现集群高可用。
kafka吞吐量高的原因。
kafka 和其他消息队列的区别，kafka 主从同步怎么实现。
利用mq怎么实现最终一致性。
使用kafka有没有遇到什么问题，怎么解决的。
MQ有可能发生重复消费，如何避免，如何做到幂等。
MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。


缓存

常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。
如何防止缓存击穿和雪崩。
缓存数据过期后的更新如何设计。
redis的list结构相关的操作。
Redis的数据结构都有哪些。
Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。
redis2和redis3的区别，redis3内部通讯机制。
当前redis集群有哪些玩法，各自优缺点，场景。
Memcache的原理，哪些数据适合放在缓存中。
redis和memcached 的内存管理的区别。
Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
Redis的选举算法和流程是怎样的。
redis的持久化的机制，aof和rdb的区别。
redis的集群怎么同步的数据的。
知道哪些redis的优化操作。
Reids的主从复制机制原理。
Redis的线程模型是什么。
请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。
如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。 
本地缓存在并发使用时的注意事项。


开源框架知识

简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
tomcat如何调优，涉及哪些参数 。
讲讲Spring加载流程。
Spring AOP的实现原理。
讲讲Spring事务的传播属性。
Spring如何管理事务的。
Spring怎么配置事务（具体说出一些关键的xml 元素）。
说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原 
理，说说aop中的几个术语，它们是怎么相互工作的。
Springmvc 中DispatcherServlet初始化过程。
netty的线程模型，netty如何基于reactor模型上实现的。
为什么选择netty。
什么是TCP粘包，拆包。解决方式是什么。
netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
netty的心跳处理在弱网下怎么办。
netty的通讯协议是什么样的。
springmvc用到的注解，作用是什么，原理。
springboot启动机制。


架构设计与分布式

用java自己实现一个LRU。
分布式集群下如何做到唯一序列号。
设计一个秒杀系统，30分钟没付款就自动关闭交易。
如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）
如果有人恶意创建非法连接，怎么解决。
分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有 
哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。
什么是一致性hash。
什么是restful，讲讲你理解的restful。
如何设计一个良好的API。
如何设计建立和保持100w的长连接。
解释什么是MESI协议(缓存一致性)。
说说你知道的几种HASH算法，简单的也可以。
什么是paxos算法， 什么是zab协议。
一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。
线上系统突然变得异常缓慢，你如何查找问题。
说说你平时用到的设计模式。
Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册 
和发现，重试转发，快速失败的策略是怎样的 。
一次RPC请求的流程是什么。
自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。
异步模式的用途和意义。
编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。
设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。
MVC模式，即常见的MVC框架。
聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。
应用服务器怎么监控性能，各种方式的区别。
如何设计一套高并发支付方案，架构如何设计。
如何实现负载均衡，有哪些算法可以实现。
Zookeeper的用途，选举的原理是什么。
Zookeeper watch机制原理。
Mybatis的底层实现原理。
请思考一个方案，实现分布式环境下的countDownLatch。
后台系统怎么防止请求重复提交。
描述一个服务从发布到被消费的详细过程。
讲讲你理解的服务治理。
如何做到接口的幂等性。
如何做限流策略，令牌桶和漏斗算法的使用场景。
什么叫数据一致性，你怎么理解数据一致性。
分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求 
的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎 
么做到最小的资源浪费，流量半开的实现机制是什么。
dubbo的泛化调用怎么实现的，如果是你，你会怎么做。
远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。


搜索

elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch的倒排索引是什么。
elasticsearch 索引数据多了怎么办，如何调优，部署。
elasticsearch是如何实现master选举的。
详细描述一下Elasticsearch索引文档的过程。
详细描述一下Elasticsearch搜索的过程。
Elasticsearch在部署时，对Linux的设置有哪些优化方法？
lucence内部结构是什么。


数据库

数据库面试知识点汇总
一、基本概念
1.主键、外键、超键、候选键
超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。

候选键：是最小超键，即没有冗余元素的超键。

主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。

外键：在一个表中存在的另一个表的主键称此表的外键。

2.为什么用自增列作为主键
如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、

如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、

如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。

数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。

3.触发器的作用？
触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。

4.什么是存储过程？用什么来调用？
存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。

调用：

1）可以用一个命令对象来调用存储过程。

2）可以供外部程序调用，比如：java程序。

5.存储过程的优缺点？
优点：

1）存储过程是预编译过的，执行效率高。

2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。

3）安全性高，执行存储过程需要有一定权限的用户。

4）存储过程可以重复使用，可减少数据库开发人员的工作量。

缺点：移植性差

6.存储过程与函数的区别


7.什么叫视图？游标是什么？
视图：

是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。

游标：

是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。

8.视图的优缺点
优点：

1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。

2)用户通过简单的查询可以从复杂查询中得到结果。

3)维护数据的独立性，试图可从多个表检索数据。

4)对于相同的数据可产生不同的视图。

缺点：

性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据

9.drop、truncate、 delete区别
最基本：

drop直接删掉表。
truncate删除表中数据，再插入时自增长id又从1开始。
delete删除表中数据，可以加where字句。
（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。

（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。

（3） 一般而言，drop > truncate > delete

（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view

（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。

（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。

（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。

（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。

（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。

（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。

（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。

（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。

10.什么是临时表，临时表什么时候删除?
临时表可以手动删除：
DROP TEMPORARY TABLE IF EXISTS temp_tb;

临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。
创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，

如：

CREATE TEMPORARY TABLE tmp_table (

NAME VARCHAR (10) NOT NULL,

time date NOT NULL
);

select * from tmp_table;

11.非关系型数据库和关系型数据库区别，优势比较?
非关系型数据库的优势：

性能：NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
可扩展性：同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
关系型数据库的优势：

复杂查询：可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
事务支持：使得对于安全性能很高的数据访问要求得以实现。
其他：

1.对于这两类数据库，对方的优势就是自己的弱势，反之亦然。

2.NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。

3.对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。

12.数据库范式，根据某个场景设计数据表?
第一范式:(确保每列保持原子性)所有字段值都是不可分解的原子值。

第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。
第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。
上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。

第二范式:(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。

第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。
比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。

第三范式:(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。

第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。
比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。

BCNF:符合3NF，并且，主属性不依赖于主属性。

若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。
通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。
BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。
还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。
一般，一个数据库设计符合3NF或BCNF就可以了。

第四范式:要求把同一表内的多对多关系删除。

第五范式:从最终结构重新建立原始结构。

13.什么是 内连接、外连接、交叉连接、笛卡尔积等?
内连接: 只连接匹配的行

左外连接: 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行

右外连接: 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行

例如1：
SELECT a.,b. FROM luntan LEFT JOIN usertable as b ON a.username=b.username

例如2：
SELECT a.,b. FROM city as a FULL OUTER JOIN user as b ON a.username=b.username

全外连接: 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。

交叉连接: 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配

例如：
SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type

注意：

很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：

牛客网数据库SQL实战

leetcode中文网站数据库练习

我的另一篇文章，常用sql练习50题

14.varchar和char的使用场景?
1.char的长度是不可变的，而varchar的长度是可变的。

定义一个char[10]和varchar[10]。
如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。

2.char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。
char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。
varchar是以空间效率为首位。

3.char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。
varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。

4.两者的存储数据都非unicode的字符数据。

15.SQL语言分类
SQL语言共分为四大类：

数据查询语言DQL
数据操纵语言DML
数据定义语言DDL
数据控制语言DCL。
1. 数据查询语言DQL

数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：

SELECT
FROM
WHERE

2 .数据操纵语言DML

数据操纵语言DML主要有三种形式：

1) 插入：INSERT

2) 更新：UPDATE

3) 删除：DELETE

3. 数据定义语言DDL

数据定义语言DDL用来创建数据库中的各种对象-----表、视图、索引、同义词、聚簇等如：
CREATE TABLE/VIEW/INDEX/SYN/CLUSTER

表 视图 索引 同义词 簇

DDL操作是隐性提交的！不能rollback

4. 数据控制语言DCL

数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：

1) GRANT：授权。

2) ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚---ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：
SQL>ROLLBACK;

3) COMMIT [WORK]：提交。

在数据库的插入、删除和修改操作时，只有当事务在提交到数据
库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看
到所做的事情，别人只有在最后提交完成后才可以看到。
提交数据有三种类型：显式提交、隐式提交及自动提交。下面分
别说明这三种类型。

(1) 显式提交
用COMMIT命令直接完成的提交为显式提交。其格式为：
SQL>COMMIT；

(2) 隐式提交
用SQL命令间接完成的提交为隐式提交。这些命令是：
ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，
EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。

(3) 自动提交
若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，
系统将自动进行提交，这就是自动提交。其格式为：
SQL>SET AUTOCOMMIT ON；

参考文章：
https://www.cnblogs.com/study-s/p/5287529.html

16.like %和-的区别
通配符的分类:

%百分号通配符:表示任何字符出现任意次数(可以是0次).

**_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.

like操作符: LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.

注意: 如果在使用like操作符时,后面的没有使用通用匹配符效果是和=一致的,SELECT * FROM products WHERE products.prod_name like '1000';
只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.

%通配符使用: 匹配以"yves"开头的记录:(包括记录"yves") SELECT FROM products WHERE products.prod_name like 'yves%';
匹配包含"yves"的记录(包括记录"yves") SELECT FROM products WHERE products.prod_name like '%yves%';
匹配以"yves"结尾的记录(包括记录"yves",不包括记录"yves ",也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like '%yves';

_通配符使用: SELECT *FROM products WHERE products.prod_name like '_yves'; 匹配结果为: 像"yyves"这样记录.
SELECT* FROM products WHERE products.prodname like 'yves_'; 匹配结果为: 像"yvesHe"这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)

注意事项:

注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被"yves__"这样的匹配条件匹配的.
注意尾部空格,"%yves"是不能匹配"heyves "这样的记录的.
注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like '%;是匹配不到products.prod_name为NULL的的记录.
技巧与建议:

正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。

不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。
在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。
仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.
参考博文：https://blog.csdn.net/u011479200/article/details/78513632

**17.count(*)、count(1)、count(column)的区别**
count(*)对行的数目进行计算,包含NULL

count(column)对特定的列的值具有的行数进行计算,不包含NULL值。

count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。

性能问题:

1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;

2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL = ‘value’ 这种查询;

3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 = ‘value’ 的出现。

如果表没有主键,那么count(1)比count(*)快。

如果有主键,那么count(主键,联合主键)比count(*)快。

如果表只有一个字段,count(*)最快。

count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。

18.最左前缀原则
多列索引：

ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);

为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。

注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。

最左前缀原则：顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。

二、索引
1.什么是索引？
何为索引：

数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。

2.索引的作用？它的优点缺点是什么？
索引作用：

协助快速查询、更新数据库表中数据。

为表设置索引要付出代价的：

一是增加了数据库的存储空间
二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。

3.索引的优缺点？
创建索引可以大大提高系统的性能（优点）：

1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。

2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。

3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。

4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。

5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。

增加索引也有许多不利的方面(缺点)：

1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。

3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

4.哪些列适合建立索引、哪些不适合建索引？
索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。

一般来说，应该在这些列上创建索引：

（1）在经常需要搜索的列上，可以加快搜索的速度；

（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；

（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；

（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；

（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；

（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

对于有些列不应该创建索引：

（1）对于那些在查询中很少使用或者参考的列不应该创建索引。

这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。

（2）对于那些只有很少数据值的列也不应该增加索引。

这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。

（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。

这是因为，这些列的数据量要么相当大，要么取值很少。

(4)当修改性能远远大于检索性能时，不应该创建索引。

这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。

5.什么样的字段适合建索引
唯一、不为空、经常被查询的字段

6.MySQL B+Tree索引和Hash索引的区别?
Hash索引和B+树索引的特点：

Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;

B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;

为什么不都用Hash索引而使用B+树索引？

Hash索引仅仅能满足"=","IN"和""查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；

Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；

Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；

Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；

Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。

补充：

1.MySQL中，只有HEAP/MEMORY引擎才显示支持Hash索引。

2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。
B+树索引和哈希索引的明显区别是：

3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；

4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；

5.哈希索引也不支持多列联合索引的最左匹配规则；

6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。

7.B树和B+树的区别
B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。

B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)

8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？
1.B+的磁盘读写代价更低

B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。

2.B+tree的查询效率更加稳定

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

9.聚集索引和非聚集索引区别?
聚合索引(clustered index):

聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。
聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。

非聚合索引(nonclustered index):

非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。
非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。

根本区别：

聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。

三、事务
1.什么是事务？
事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。

2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?
原子性（Atomicity）:
原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。

一致性（Consistency）:
事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。

隔离性（Isolation）:
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

持久性（Durability）:
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。

3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?
从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。
事务的并发问题

1、脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据

2、不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

3、幻读：幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。

例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

事务的隔离级别



读未提交：另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读

不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。

可重复读：在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象

串行化：最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样

特别注意：

MySQL默认的事务隔离级别为repeatable-read

MySQL 支持 4 中事务隔离级别.

事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.

Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE

SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异

MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行

事务隔离级别：未提交读时，写数据只会锁住相应的行。

事务隔离级别为：可重复读时，写数据会锁住整张表。

事务隔离级别为：串行化时，读写数据都会锁住整张表。

隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

4.事务传播行为
1.PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。

2.PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。

3.PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。

4.PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。

5.PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

6.PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。

7.PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

5.嵌套事务
什么是嵌套事务？

嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：

如果子事务回滚，会发生什么？

父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。

如果父事务回滚，会发生什么？

父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：

事务的提交，是什么情况？

是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。

参考文章：https://blog.csdn.net/liangxw1/article/details/51197560

四、存储引擎
1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?
两种存储引擎的大致区别表现在：

1.InnoDB支持事务，MyISAM不支持， 这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。

2.MyISAM适合查询以及插入为主的应用。

3.InnoDB适合频繁修改以及涉及到安全性较高的应用。

4.InnoDB支持外键，MyISAM不支持。

5.从MySQL5.5.5以后，InnoDB是默认引擎。

6.InnoDB不支持FULLTEXT类型的索引。

7.InnoDB中不保存表的行数，如select count() from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count()语句包含where条件时MyISAM也需要扫描整个表。

8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。

9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。

10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a=1 where user like '%lee%'。

2.MySQL存储引擎MyISAM与InnoDB如何选择
MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。

虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。
关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：

1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。
2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。
如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。

如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。

有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。

现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。
MEMORY存储引擎

MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。
每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。

MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。

注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。

3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?
事务处理上方面

MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。

InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。

锁级别

MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。

InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。

关于存储引擎MyISAM和InnoDB的其他参考资料如下：

MySQL存储引擎中的MyISAM和InnoDB区别详解

MySQL存储引擎之MyISAM和Innodb总结性梳理

五、优化
1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?
1.查询中用到的关键词主要包含六个，并且他们的顺序依次为 select--from--where--group by--having--order by
其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行

from:需要从哪个数据表检索数据

where:过滤表中数据的条件

group by:如何将上面过滤出的数据分组

having:对上面已经分组的数据进行过滤的条件

select:查看结果集中的哪个列，或列的计算结果

order by :按照什么样的顺序来查看返回的数据

2.from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。
也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）

其他参考资源：
http://www.cnblogs.com/huminxxl/p/3149097.html

2.使用explain优化sql和索引?
对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化

table：显示这一行的数据是关于哪张表的

type：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL

all:full table scan ;MySQL将遍历全表以找到匹配的行；

index: index scan; index 和 all的区别在于index类型只遍历索引；

range：索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；

ref：非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；

eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；

const，system：当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。

possible_keys：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句

key： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引

key_len：使用的索引的长度。在不损失精确性的情况下，长度越短越好

ref：显示索引的哪一列被使用了，如果可能的话，是一个常数

rows：MySQL认为必须检查的用来返回请求数据的行数

Extra：关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。

3.MySQL慢查询怎么解决?
slow_query_log 慢查询开启状态。

slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。

long_query_time 查询超过多少秒才记录。

六、数据库锁
1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?
MySQL有三种锁的级别：页级、表级、行级。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
什么情况下会造成死锁?
什么是死锁？

死锁: 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。

表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。

死锁的关键在于：两个(或以上)的Session加锁的顺序不一致。

那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。

死锁的解决办法?

1.查出的线程杀死 kill
SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;

2.设置锁的超时时间
Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。

生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值
该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：
set innodb_lock_wait_timeout=1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。

3.指定获取锁的顺序

2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?
悲观锁（Pessimistic Lock）:

悲观锁特点:先获取锁，再进行业务操作。

即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的“一锁二查三更新”即指的是使用悲观锁。通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。

补充：
不同的数据库对select for update的实现和支持都是有所区别的，

oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。
MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。
乐观锁（Optimistic Lock）:

1.乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。

2.乐观锁的特点先进行业务操作，不到万不得已不去拿锁。即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。
乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。

3.一般的做法是在需要锁的数据上增加一个版本号，或者时间戳，

实现方式举例如下：

乐观锁（给表加一个版本号字段） 这个并不是乐观锁的定义，给表加版本号，是数据库实现乐观锁的一种方式。

SELECT data AS old_data, version AS old_version FROM …;
根据获取的数据进行业务操作，得到new_data和new_version
UPDATE SET data = new_data, version = new_version WHERE version = old_version
if (updated row > 0) {

// 乐观锁获取成功，操作完成

} else {

// 乐观锁获取失败，回滚并重试

}

注意：

乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能
乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。
总结：
悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select ... for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。

响应速度： 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。

冲突频率： 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。

重试代价： 如果重试代价大，建议采用悲观锁。

七、其他
1.数据库的主从复制
主从复制的几种方式:

同步复制:

所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,...,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。

异步复制:

如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。

半同步复制:

master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。

2.数据库主从复制分析的 7 个问题?
问题1：master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？

假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。

问题2：主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？

实现数据备份:
类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。

异地容灾:比如master在北京，地震挂了，那么在上海的slave还可以继续。
主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。
【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】

问题3：主从复制中有master,slave1,slave2,...等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?

我们在应用程序中可以这样，insert/delete/update这些更新数据库的操作，用connection(for master)进行操作，

select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。

这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？
找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。
MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。

这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。

问题4：如果MySQL proxy , direct , master他们中的某些挂了怎么办？

总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。

问题5：当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,...它们怎么办？

显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,...的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。

问题6：当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。

应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,...这些查询的结果都缓存至mamcache中。

问题7：随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？

scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。
scale out ? 主从复制架构已经满足不了。
可以分库【垂直拆分】：表多，把关系紧密（比如同一模块）的表切分出来放在一个server上
分表【水平拆分】：表的数据多，把表的数据按某种规则（比如按ID散列）切分到多个数据库(server)上，

3.mysql 高并发环境解决方案?
MySQL 高并发环境解决方案： 分库 分表 分布式 增加二级缓存。。。。。

需求分析：互联网单位 每天大量数据读取，写入，并发性高。

现有解决方式：水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。

集群方案：解决DB宕机带来的单点DB不能访问问题。

读写分离策略：极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。

4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?
转载：MySQL REDO日志和UNDO日志

Undo Log:

Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。

事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。
原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

之所以能同时保证原子性和持久化，是因为以下特点：

更新数据前记录Undo log。
为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。
Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。
如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。

缺陷：每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。
如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。

Redo Log:

原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。