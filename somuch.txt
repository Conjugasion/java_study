JAVA基础

JAVA中的几种基本数据类型是什么，各自占用多少字节。
boolean 1b, byte 1b, char 2b, short 2b, int 4b, long 8b, float 4b, double 8b


String类能被继承吗，为什么。
不能，final修饰


String，Stringbuffer，StringBuilder的区别。
不可变类， 可变线程安全，  可变线程不安全


ArrayList和LinkedList有什么区别。
数组实现，扩容时拷贝，查找方便；链表实现，增删方便


讲讲类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字 
段，当new的时候，他们的执行顺序。
父类静态数据 and 父类静态代码块 > 子类静态数据 and 子类静态代码块 > 父类普通变量、非静态代码块、构造方法 > 子类普通变量、非静态代码块、构造方法


用过哪些Map类，都有什么区别，HashMap是线程安全的吗,并发下使用的Map是什么，他们内部原理分别是什么，比如存储方式，hashcode，扩容，默认容量等。
hashtable             hashmap                 linkedhashmap                treemap
线程安全           线程不安全效率高          线程不安全插入顺序即存储顺序  可以按照指定顺序存储数据，自动排序
 哈希表               哈希表                  hashmap+双向链表记录顺序         红黑树
hashmap/linkedhashmap冲突个数超过8(默认值)的列表，jdk1.8中采用了红黑树的结构，那么查询的时间复杂度可以降低到O(logN)
存入TreeMap的元素应当实现Comparable接口或者实现Comparator接口，treemap的key不允许null，value允许null；              
Hashtable计算hash是直接使用key的hashcode对table数组的长度直接进行取模
HashMap计算hash对key的hashcode进行了二次hash，以获得更好的散列值，然后对table数组长度取模
HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75
HashMap扩容时是当前容量翻倍即:capacity*2，Hashtable扩容时是容量翻倍+1即:capacity*2+1
HashMap是非线程安全的,只是用于单线程环境下,多线程环境下可以采用concurrent并发包下的concurrentHashMap。HashTable是线程安全的,synchronized
HashMap/linkedhashmap中key和value都允许为null。key为null的键值对永远都放在以table[0]为头结点的链表中。
HashTable在 key、value 遇到null时，会抛出NullPointerException异常
HashMap仅支持Iterator的遍历方式，Hashtable支持Iterator和Enumeration两种遍历方式

				 
JAVA8的ConcurrentHashMap为什么放弃了分段锁，有什么问题吗，如果你来设计，你如何设计。
1.7 ConcurrentHashMap加锁粒度是基于Segment（ReentrantLock）的，包含多个HashEntry。多个线程同时竞争获取同一个segment锁，获取成功的线程更新
map；失败的线程尝试多次获取锁仍未成功，则挂起线程，等待释放锁
1.8 ConcurrentHashMap加锁粒度是基于HashEntry，采用Synchronized和CAS，锁粒度变小了。当bucket为空时，使用CAS操作，将Node放入对应的bucket中当出现hash冲突时，则采用synchronized关键字。链表超过一定长度会转成红黑树。


有没有有顺序的Map实现类，如果有，他们是怎么保证有序的。
linkedhashmap： hashmap+双向链表记录顺序
treemap： 自定义排序，自动维护顺序， 红黑树


抽象类和接口的区别，类可以继承多个类么，接口可以继承多个接口么,类可以实现多个接口么。
接口方法默认public static，接口变量默认public staic final，方法一般是不能实现的；抽象类可以有抽象方法也可以具体方法。
类不可以继承多个类，但是可以实现多个接口，接口可以继承多个接口。


IO模型有哪些，讲讲你理解的nio ，他和bio，aio的区别是啥，谈谈reactor模型。
同步阻塞的BIO，面向流，都是inputstream和outputstream，服务端启动一个severSocket监听特定端口，然后客户端创建指定ip地址和端口的socket去连接服务器。每有一个客户端连接进来，服务器都要创建一个线程，当有大量客户端连接时，服务器会不堪重负。
同步非阻塞的NIO，面向缓存，从channel读到buffer，从buffer写到channel。事件驱动型，Reactor设计模式，socket会注册感兴趣的事件，少量线程负责轮询socket，当感兴趣的事件准备好的时候，再创建一个线程去处理。但是具体的IO读写还是阻塞的。
异步非阻塞AIO，Proactor设计模式，不用用户线程亲自读写，OS会把可读的流传入read方法缓冲区，write方法的写入完毕时会通知用户线程。


反射的原理，反射创建类实例的三种方式是什么。
根据类名找到对应的.class文件，通过字节码文件进行一系列操作
Class clazz = Class.forname()；
Class clazz = 实例.getClass()；
Class clazz = 类.class


反射中，Class.forName和ClassLoader区别 。
JVM加载class有三个步骤：加载，链接(检查、准备、解析)，初始化
Class.forname()得到的class对象是已经初始化完毕的。
ClassLoader得到的class对象还没有链接，仅仅加载了而已，不会执行static中的内容,只有在newInstance才会去执行static块。


描述动态代理的几种实现方式，分别说出相应的优缺点。
1. 原生JDK方式。代理类和目标类实现同一接口，代理类持有目标类对象来达到拦截的目的。必须借助接口才能产生代理对象，只有在接口中声明的方法，代理类才能进行拦截。
2. CGLIB，底层使用ASM在内存中动态生成被代理类的子类，即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB简单易用，它的运行速度要远远快于JDK的Proxy动态代理
3. asm
4. javassist


动态代理与cglib实现的区别。
1.原生JDK方式。代理类和目标类实现同一接口，代理类持有目标类对象，来达到拦截的目的。必须借助接口才能产生代理对象，只有在接口中声明的方法，代理类才能进行拦截。
2.CGLIB，底层使用ASM在内存中动态生成被代理类的子类，即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB简单易用，它的运行速度要远远快于JDK的Proxy动态代理


为什么CGlib方式可以对接口实现代理。
CGLIB，底层使用ASM在内存中动态生成被代理类的子类，即使代理类没有实现任何接口也可以实现动态代理功能。CGLIB简单易用，它的运行速度要远远快于JDK的Proxy动态代理


final的用途。
1.final修饰类，类不能被继承
2.final修饰基本类型变量，变量的值不能修改
3.final修饰引用变量，变量不能被指向其它对象
4.final修饰方法，方法不能被重写，但是能被重载


写出三种单例模式实现 。
1.饿汉式
public class Singleton{
	private staic Singleton instance = new Singleton();
	private Singleton(){
		System.out.println("构造方法");
	}
	public Singleton getSingleton(){
		return instance;
	}
}
tips:调用外部类的静态变量和静态方法，不会初始化静态内部类
2.public class Singleton{
	private Singleton(){
		System.out.println("构造方法");
	}
	private static class InnerSingleton{
		private final staic Singleton instance = new Singleton(); 
	}
	public Singleton getSingleton(){
		return InnerSingleton.instance;
	}
}
加同步锁，前后两次判断
3.public class Singleton{
	private Singleton instance = null;
	private Singleton{
		System.out.println("构造方法");
	}
	public Singleton getSingleton(){
		if (instance==null) {
			synchronized(Singleton.class){
				if (instance==null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}


请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
public 对所有人都开放，private 仅对本类成员开放， protected 对本类、子类、本包开放， default 对本类和本包开放


深拷贝和浅拷贝区别。
浅拷贝：源本和副本共享相同的引用类型对象，基本类型是各自一份的，所以修改引用类型会引起源本和副本的同时变化，修改基本类型不会引起同时变化。
深拷贝：源本和副本引用类型和基本类型都是各自一份，所以修改只会影响自己。
Object.clone()实现浅拷贝，若要实现深拷贝，需要将对象引用到的所有类都 implement Cloneable 接口(重写clone方法)，比较麻烦
可以采用序列化的方法实现简单深拷贝，需要将对象引用到的所有类都 implements Serializable 接口(不需要重写方法)
transient 和 static 修饰的属性不能被序列化


error和exception的区别，CheckedException，RuntimeException的区别。
error 表示虚拟机发生了严重错误，必须修改程序。
exception 表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。
CheckedException 受查异常/编译时异常 编写代码的时候必须考虑到的异常，可以 throws 或者 try-catch。
RuntimeException 非受查异常/运行时异常 不需要捕获，一旦抛出 RuntimeException 异常，请修改程序。


请列出5个运行时异常。
空指针异常 NullPointerException 
类找不到异常 ClassNotFoundException 
算数异常 ArithmeticException
数组越界异常 ArrayIndexOutOfBoundsException
类型转换异常 ClassCastException


在自己的代码中，如果创建一个java.lang.String类，这个类是否可以被类加载器加载？为什么？
不可以，因为存在双亲委派模型模型。先交给 bootStrap ClassLoader，若无法加载在交给 extension ClassLoader，若还不能加载则交给 System ClassLoader
通过双亲委托模式传递到引导加载器，而引导加载器在核心 Java API 发现这个名字的类，所以会加载该核心类，并不会加载自己写 java.lang.String类。
这样便可以防止核心API库被随意篡改。
public class String {
    public static void main(String[] args) {
        String str = "my String";
        System.out.println(str);
    }
}
错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:
   public static void main(String[] args)
否则 JavaFX 应用程序类必须扩展javafx.application.Application

如果我们在 classpath 路径下自定义一个名为 java.lang.MyString 类(该类是胡编的)呢？该类并不存在 java.lang中，经过双亲委托模式，传递到启动类加载器中，
由于父类加载器路径下并没有该类，所以不会加载，将反向委托给子类加载器加载，最终会通过 System 加载器加载该类。
但是这样做是不允许，因为 java.lang 是核心API包，需要访问权限，强制加载将会报出如下异常：
java.lang.SecurityException: Prohibited package name: java.lang


说一说你对java.lang.Object对象中 hashCode和equals方法的理解。在什么场景下需要重新实现这两个方法。
两个对象属性相同应当认为这两个对象是相同的，而不能简单的去比较两个对象的内存地址是否相同。equals 比较的是两个对象的属性，若 equals返回true，
两个对象的hashcode必须相等；若两个对象的 hashcode相等，equals不一定为true。
需要根据对象属性去判断两个对象是否相等的场景需要重写 hashcode 和 equals


在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
泛型的主要目标是实现 java 的类型安全。 泛型可以使编译器知道一个对象的限定类型是什么，从而检查是否有代码错误。
消除了强制类型转换 使得代码可读性好，减少了很多出错的机会


这样的a.hashcode() 有什么用，与a.equals(b)有什么关系。
默认调用 object 的hashcode方法，用于计算对象的内存地址。equals在不重写的情况下，使用的是object默认的 equals，调用==比较的也是对象的内存地址。


有没有可能2个不相等的对象有相同的hashcode。
可能，hash冲突


Java中的HashSet内部是如何工作的。
hashSet基于hashMap实现，因为 hashMap 的 key 是不能重复的，value 是统一的 public final static Object PRESENT = new Object()。
往 HashSet 中添加元素，首先判断元素（也就是key）是否存在，如果不存在这插入，如果存在着不插入，这样 HashSet 中就不存在重复值。


什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
将 JVM 中的对象持久化保存到磁盘，只要一个类实现了 java.io.Serializable 接口，那么它就可以被序列化。
FileOutputStream fs = new FileOutputStream();
ObjectOutputSream os = new ObjectOutputSream(fs);
os.writeObject(对象);
os.close();
序列化的作用就是为了不同 jvm 之间共享实例对象;内存中的对象状态保存到一个文件中或者数据库中时候；当你想用套接字在网络上传送对象的时候；当你想通过RMI传输对象的时候；
transient 和 static 修饰的变量不参与序列化
serialVersionUID 不要去改动


java8的新特性。
Lambda 表达式，Stream API，接口默认方法


什么情况下会发生栈内存溢出。
递归太深


JVM的内存结构，Eden和Survivor比例。
8:1:1


JVM内存为什么要分成新生代，老年代，持久代。新生代中为什么要分为Eden和Survivor。
持久带存放字符串常量池、类的基本信息，默认大小 4m，Jdk8 已经直接取消了 Perm 区域，新建了一个分配在本地内存的元空间。
因为新生代采用复制算法，Eden和to的存活对象复制到from，然后删除Eden和to中的对象，最后from和to互换。


JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代，说说你知道的几种主要的JVM参数。
-XX:+printGC(打印GC)；-XX:+PrintGCDetails；(打印GC细节)-XX:+PrintHeapAtGC；(在GC时打印堆状况)-XX:+TraceClassLoading；(打印class加载细节)
-Xmx（最大堆的空间)；-Xms（最小堆的空间）; -Xmn (设置新生代的大小)；-XX:NewRatio(新生代和老年代比例)；-XX:SurvivorRatio；-Xss（设置栈空间的大小）;
-XX:+HeapDumpOnOutOfMemoryError；


你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1，包括原理，流程，优缺点。
新生代垃圾收集器： Serial，采用复制算法，单线程，在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				ParNew，Serial 的多线程版，采用复制算法，在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				Parallel Scavenge，多线程，采用复制算法，吞吐量优先,运行代码时间/(运行代码时间+垃圾收集时间)，最高效率地利用CPU时间，
				尽快地完成程序的运算任务,在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				G1......

老年代垃圾收集器： Serial Old，采用标记-整理算法，单线程，在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				Parallel Old,采用标记-整理算法，多线程，吞吐量优先,在进行垃圾回收时会暂停其他所有工作线程(stop the world)
				CMS 采用标记-清除算法，多线程，主要目标是获取最短垃圾回收停顿时间，真正意义上并发垃圾收集器，它第一次实现了让垃圾收集线程和用户线程同时工作。
				G1 基于标记-整理算法，高垃圾收集效率。可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
				G1收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，
				同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。


垃圾回收算法的实现原理。
标记清除算法；标记整理算法；复制算法；分代收集算法
GC Root：栈中的对象


当出现了内存溢出，你怎么排错。
-XX:+HeapDumpOnOutOfMemoryError，Mat分析堆转储文件


JVM内存模型的相关知识了解多少，比如重排序，内存屏障，happen-before，主内存，工作内存等。
重排序指编译器和处理器为了优化程序性能而对指令序列进行重新排序的手段。
对于有数据依赖的代码，不会重排序，比如写后读、写后写和读后写，as-if-serial；
happen-before是指A 操作 happen-before B 操作，只要保证结果正确，具体指令按什么顺序执行时可以重排序的。
as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。
传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。
join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。

内存屏障
Store：将cache的数据刷新到内存中。Load：将内存存储的数据拷贝到cache中。
四种屏障：loadload、storestore、loadstore、storeload


简单说说你了解的类加载器，可以打破双亲委派么，怎么打破。
bootStrap ClassLoader、extension ClassLoader 和 System ClassLoader
首先自己写一个加载器继承 ClassLoader，重写loadClass和findClass方法
两个类是否相同，需要他们的加载器相同！ 所以即使自己自定义加载器加载自己写的java.lang.String，系统也不认为该类就是真正的String


讲讲JAVA的反射机制。
反射就是对.class文件(字节码)进行一系列操作，包括获取所有变量、属性、方法、构造器...


g1和cms区别,吞吐量优先和响应优先的垃圾收集器选择。
CMS 是多线程老年代垃圾回收器，基于标记-清除算法，是真正意义上的并发垃圾收集器，追求最短的垃圾回收停顿时间。大概分为四步，首先初始标记(stop the world)，
标记出root可达的对象，然后并发标记，跟踪可达对象，再标记可达对象，接着重新标记(stop the world)，标记可达对象，最后并发清理。缺点是占用cpu，清理不彻底。
G1 基于对于新生代采用复制算法，对于老年代采用标记-整理算法，高垃圾收集效率。可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。
G1 垃圾收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，
每次根据所允许的收集时间，优先回收垃圾最多的区域。


怎么打出线程栈信息。
jstack


请解释如下jvm参数的含义： 
-server -Xms512m -Xmx512m -Xss1024K 
server: 指java启用JIT的Server Compiler，全局优化，优化比较慢，client Compiler 仅采用局部优化，优化比较快。
java堆最小512M，最大512M，栈空间大小1024K
-XX:PermSize=256m -XX:MaxPermSize=512m
永久代大小初始256m，最大512m
-XX:MaxTenuringThreshold=20
新生代晋升老年代的年龄阈值，默认15； 
-XX:MSInitiatingOccupancyFraction=80 -XX:+UseCMSInitiatingOccupancyOnly。
当内存被占用达到80%时，启动full GC；指定cms使用手动设定的阈值full GC，否则只有第一次会在80%时GC，之后则自动调整


操作系统

Linux系统下你关注过哪些内核参数，说说你知道的。
fs.file-max 和 ulimit: 前者是指整个系统最大能打开的文件描述符的数量，后者指某个进程最大能打开的文件描述符的数量。

net.ipv4.tcp_fin_timeout = 2           #保持在FIN-WAIT-2状态的时间，使系统可以处理更多的连接。此参数值为整数，单位为秒。
net.ipv4.tcp_max_tw_buckets = 5000     #系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数值将立刻被清楚并输出警告信息。默认值为180000。对于squid来说效果不是很大，但可以控制TIME_WAIT套接字最大值，避免squid服务器被拖死。 
net.ipv4.tcp_tw_reuse = 1              #开启重用，允许将TIME_WAIT socket用于新的TCP连接。默认为0，表示关闭。
net.ipv4.tcp_tw_recycle = 1            #开启TCP连接中TIME_WAIT socket的快速回收。默认值为0，表示关闭。

net.ipv4.tcp_max_syn_backlog = 262144  #表示SYN队列的长度，预设为1024，这里设置队列长度为262144，以容纳更多的等待连接。
net.ipv4.tcp_syncookies = 1            #开启SYN cookie，出现SYN等待队列溢出时启用cookie处理，防范少量的SYN攻击。默认为0，表示关闭。
net.core.somaxconn = 16384             #定义了系统中Accept队列长度, 即完成三次握手的连接数量，对于一个经常处理新连接的高负载web服务环境来说，默认值为128，偏小。

net.ipv4.tcp_keepalive_time = 600      #keepalived启用时TCP发送keepalived消息的频度。
net.ipv4.tcp_keepalive_probes = 5      #TCP发送keepalive探测以确定该连接已经断开的次数。根据情形也可以适当地缩短此值。
net.ipv4.tcp_keepalive_intvl = 15      #探测消息发送的频率，乘以tcp_keepalive_probes就得到对于从开始探测以来没有响应的连接杀除的时间。默认值为75秒。对于普通应用来说,这个值有一些偏大,可以根据需要改小.特别是web类服务器需要改小该值。
net.ipv4.ip_local_port_range = 1024 65000 #指定外部连接的端口范围。默认值为32768 61000。
net.ipv4.tcp_max_orphans = 16384       #表示系统中最多有多少TCP套接字不被关联到任何一个用户文件句柄上。如果超过这里设置的数字，连接就会复位并输出警告信息。这个限制仅仅是为了防止简单的DoS攻击。此值不能太小。 


Linux下IO模型有几种，各自的含义是什么。
阻塞IO：传统IO                                                                        
非阻塞IO：用户线程不断轮询内核数据是否准备好了，长期占用cpu。          
多路复用IO：Reactor模式，由单个内核线程不断轮询多个socket channel状态。
信号驱动型IO：每个socket注册一个信号函数，当数据就绪时会发送一个信号给用户线程，然后用户线程进行IO读写。				   				   
异步IO：用户线程发起IO请求，立刻就可以去做自己的事情。用户线程和内核线程通过mmap映射同一块内存区域，内核会等待数据准备完成，然后将数据读取到共享内存。最后告知用户线程IO操作已经完成，可以直接使用数据了。                   


epoll和poll有什么区别。
poll:和select没啥区别。采用遍历fd的方式获取已经就绪的socket。因为是基于链表存储，所以没有监视文件描述符的数量限制。
	 仅支持水平触发模式，如果报告的fd没有被处理，下次轮询还是会报告该fd。
epoll:linux特有，支持水平触发和边缘触发；边缘触发:仅会通知一次fd就绪的消息，若没有处理，下次也不会通知了。
	 使用”事件“就绪通知方式，使用epoll_ctl注册fd，一旦该fd就绪，内核会调用callback回调机制激活fd，epoll_wait会收到通知。
	 没有并发连接限制(1G -> 10W连接)，不采用轮询方式。epoll采用mmap技术。
	 如果没有大量空闲连接，epoll效率和poll/select差不多


用一行命令查看文件的最后五行。
tail -n 5 filename
用一行命令查看文件的开头五行。
head -n 5 filename
查看文件的第三行到第五行
cat filename | tail -n +3 | head -n 5
将标准输出流和错误输出流都重定向到log
ls filename > log 2>&1


用一行命令输出正在运行的java进程。
jps


介绍下你理解的操作系统中线程切换过程。
线程切换不需要切换内存映射表，只需要切换指令。
用户级线程切换，切换栈即可；核心级线程切换，需要切换一套栈，核心栈和用户栈


top 命令之后有哪些内容，有什么作用。
进程号、进程所有者、进程名，ni静态优先级-20~19，越低优先级越高，pr动态优先级，virt进程使用的虚拟内存总量，shr共享内存大小，res进程使用的未被换出的物理内存大小
S进程状态， %CPU CPU使用率，%MEM 内存使用率，TIME 进程使用时间


source、sh、bash和.运行脚本有什么区别
./jiaoben.sh 需要脚本有执行权限，source、sh和bash不需要脚本有执行权限；source和.是在当前shell内执行脚本，同一个进程号，而sh和bash是另起一个进程执行脚本


僵尸进程和孤儿进程
僵尸进程:父进程还在运行，子进程却挂了，父进程没有使用wait来清理子进程信息，导致系统中还保留着一些子进程信息，浪费系统资源
孤儿进程:子进程还在运行，父进程却挂了，子进程会交给init进程统一管理，完成状态收集工作


linux下进程的五种状态
就绪状态，运行状态，中止状态，
可中断睡眠状态:进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。
不可中断睡眠状态:进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。
僵死状态:僵尸进程，虽然线程已死亡，但是系统中还残留部分信息


多线程

多线程的几种实现方式，什么是线程安全。
继承Thread类、实现Runnable借口、实现Callable接口


volatile的原理，作用，能代替锁么。
不能代替锁。被volatile修饰的变量每次都从主存中读取，并且禁止指令重排序。volatile变量是一种比sychronized关键字更轻量级的同步机制


画一个线程的生命周期状态图。
就绪状态，运行状态，阻塞状态，中止状态
中止状态:程序正常执行完毕、调用stop(会释放锁)
阻塞状态:比如调用sleep(不会释放锁),阻塞式IO读写，没有获得监视器，wait(释放锁)某个notify()，调用suspend(不会释放锁)，yield(不会释放锁)


sleep和wait的区别。
sleep不会释放锁，wait会释放锁


sleep和sleep(0)的区别。
sleep(long time) 线程在指定时间内不参与cpu竞争；sleep(0) 线程会从阻塞队列直接回到就绪队列，参与cpu竞争，是想让其他线程也有得到cpu运行的机会，


Lock与Synchronized的区别 。
Synchronized是内置锁，处于jvm层面，Lock是java类；
Synchronized无法判断是否获取锁，Lock可以判断是否获取到锁；
Synchronized会自动释放锁，Lock需在finally中手工释放锁；
Synchronized会导致无法获得锁的线程一直等待，Lock可以tryLock(time)，若还不能获得锁则执行别的逻辑
Synchronized可重入、不可中断、非公平，Lock可重入、可中断、可公平、可不公平
Synchronized锁适合代码少量的同步问题，Lock锁适合大量同步的代码的同步问题。


synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静态方法和非静态方法同时执行的时候会有影响吗)。
同步代码块是使用MonitorEnter和MoniterExit指令实现的，在编译时，MonitorEnter指令被插入到同步代码块的开始位置，MoniterExit指令被插入到同步代码块的结束位置和异常位置。
加在静态方法前锁定的是整个类，加在非静态方法前锁定的是当前对象。
修饰静态方法，锁是加在类上的，类的所有对象竞争一把锁;修饰非静态方法，锁加在单个对象上，不同对象间没有竞争关系。


解释以下名词：重排序，自旋锁，偏向锁，轻量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。
重排序:编译器和处理器为了优化程序性能而对指令进行重新排序
自旋锁:为了编译线程上下文切换带来的损耗，所以让线程空等待
偏向锁:在没有实际竞争的情况下，自始至终都只有一个线程在使用锁，降低获取锁的消耗，仅要一次CAS操作
轻量级锁:无实际竞争，多个线程交替使用锁，允许短时间的锁竞争(自旋)
可重入锁:线程可以进入它拥有的锁所同步的代码块
公平锁:加锁前先查看是否有排队等待的线程，有的话优先处理排在前面的线程，先来先得
非公平锁:随机获得锁
乐观锁:假设一定会发生并发冲突，通过阻塞其他所有线程来保证数据的完整性。比如Synchronized
悲观锁:假设不会发生并发冲突，直接不加锁去完成某项更新，如果冲突就返回失败。比如CAS机制


用过哪些原子类，他们的原理是什么。
AtomicInteger、AtomicLong、AtomicBoolean，CAS


JUC下研究过哪些并发工具，讲讲原理。
CountDownLatch:使一个线程等待其他线程都执行完毕后才开始执行
CyclicBarrier:所有线程相互等待，只有当所有线程都到达某个点之后才能开始接着往下做
Semaphore:限制同一时刻访问某种资源的线程数量
Exchanger:交换器,两个线程到达同步点后交换数据


用过线程池吗，如果用过，请说明原理，并说说newCache和newFixed有什么区别，构造函数的各个参数的含义是什么，比如coreSize，maxsize等。
ThreadPoolExecutor(......)
corePoolSize核心线程数量，maxsize核心线程+非核心线程数量，keepAliveTime非核心线程最大闲置时间，timeUnit时间单位，workQueue等待队列
threadFactory工厂方法，Reject拒绝机制
几种常用的线程池
CachedThreadPool():new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue<Runnable>());
				   核心线程为0，核心线程数量几乎无限制，60秒限制销毁线程，等待队列为同步队列，出队和入队必须同时进行。
				   快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。
FixedThreadPool:new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>());
			    核心线程数为nThread，没有非核心线程，等待队列几乎无限制，可以存储大量任务。
			    可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。
SingleThreadPool:仅一个核心线程，一个一个的执行任务
ScheduledThreadPool:隔多久执行一个任务


线程池的关闭方式有几种，各自的区别是什么。
shutDownNow:线程池拒接收新提交的任务，同时立马关闭线程池，线程池里的任务不再执行。
shutDown:线程池拒接收新提交的任务，同时等待线程池里的任务执行完毕后关闭线程池。
awaitTermination 和 shutDown 配合使用


假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有10个线程同时调用它，如何做到。
ScheduledThreadPool + Semaphore


spring的controller是单例还是多例，怎么保证并发的安全。
Controller 默认情况下是单例模式


ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么。
用于保存某个共享变量的副本，修改、删除不会影响别的线程。Thread类中有一个成员变量属于ThreadLocalMap类，一个定义在ThreadLocal类中的内部类
ThreadLocalMap<ThreadLocal，Object>成员变量，以ThreadLocal对象为key


如果让你实现一个并发安全的链表，你会怎么做。
ConcurrentLinkedQueue，Collections.synchronizedList()


有哪些无锁数据结构，他们实现的原理是什么。
CAS


讲讲java同步机制的wait和notify。
都是Object方法，只能在同步代码块中调用，wait释放锁、线程阻塞，notify唤醒等待在监视器上的线程，使之重新加入cpu竞争


CAS机制是什么，如何解决ABA问题。
AtomicStampedReference，加版本戳/时间戳


多线程如果线程挂住了怎么办。
因为wait挂住，需要等待notify/notifyAll才能进入可执行状态
因为sleep挂住，需要等待指定时间
因为join挂住，需要等待之前的线程都完成才能执行
因为suspend挂住，需要等待resume唤醒


countdowlatch和cyclicbarrier的内部原理和用法，以及相互之间的差别(比如countdownlatch的await方法和是怎么实现的)。
CountDownLatch等待前面的线程都完成之后，后面的线程才能开始执行，递减，不可重复利用
CyclicBarrier线程相互等待，知道所有线程都完成任务到达屏障点，再一块往下执行，递加，可重复利用


对AbstractQueuedSynchronizer了解多少，讲讲加锁和解锁的流程，独占锁和公平锁加锁有什么不同。
AQS定义两种资源共享方式:独占，只有一个线程能执行，如ReentrantLock；共享，多个线程可同时执行，如Semaphore。
AQS为Java中的并发同步组件提供统一的底层支持，关键点:同步状态和同步队列
state为0，说明当前锁已经被占，需要添加到同步队列中；state为1，说明线程可以获取到锁，共享锁state大于1
同步队列:它是一个双端队列，遵循FIFO原则，主要作用是用来存放在锁上阻塞的线程，当一个线程尝试获取锁时，如果已经被占用，那么当前线程就会被构造成一个Node
	   节点插入到同步队列的尾部。队列的头节点是成功获取锁的节点，当独占锁的头节点线程释放锁时，会唤醒其直接后继节点并释放当前头节点的引用；当共享锁头
	   节点释放锁，会唤醒其后面的所有节点 


使用synchronized修饰静态方法和非静态方法有什么区别。
修饰静态方法，锁定的是这个类，修饰非静态方法锁定的是这个对象


简述ConcurrentLinkedQueue和LinkedBlockingQueue的用处和不同之处。
LinkedBlockingQueue 是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。 
ConcurrentLinkedQueue是一个基于链节点的无界线程安全队列，


导致线程死锁的原因？怎么解除线程死锁。
在死锁时，线程间相互等待资源，而又不释放自身的资源，导致无穷无尽的等待，其结果是系统任务永远无法执行完成。
释放某个线程拥有的资源，


用过读写锁吗，原理是什么，一般在什么场景下用。
ReentrantReadWriteLock 适用读比写多的场景。基于AQS实现同步功能，将同步状态state掰成两份用，读与写互斥，支持重入，但是可以从写锁降级为读锁，反之不行


延迟队列的实现方式，delayQueue和时间轮算法的异同。
延迟一段时间后触发事件
delayQueue:采用PriorityQueue实现，二叉堆实现，在插入和获取时都是O(logn)
时间轮:一个轮子，有8个“槽”，可以代表未来的一个时间。如果以秒为单位，中间的指针每隔一秒钟转动到新的“槽”上面，就好像手表一样。如果当前指针指在1上面，
	  我有一个任务需要4秒以后执行，那么这个执行的线程回调或者消息将会被放在5上。采用数组或者环形链表实现。
DelayQueue由于涉及到排序，需要调堆，插入和移除的复杂度是O(lgn)，而时间轮在插入和移除的复杂度都是O(1)。


TCP与HTTP

http1.0和http1.1有什么区别。
缓存处理，1.1引入了更多的缓存控制策略；
带宽优化，1.1允许只请求资源的某个部分；
新增错误码，1.1新增了24个错误状态响应码；
Host 头处理，HTTP1.1的请求消息和响应消息都应支持Host头域，一台服务器上可能有多台虚拟服务器共享ip，所以需要请求需要带hostname
长连接，1.1默认开启keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。


TCP三次握手和四次挥手的流程，为什么断开连接要4次,如果握手只有两次，会出现什么。
断开的时候，只有当服务器端所有的报文都发送完了，它才能发送FIN报文，因此不能一起发送。故需要四步握手。
如果只有两次握手，可能会导致服务器端建立一些实际不应该建立的连接。比如服务器接收到本来以为已经丢失的数据报，就会返回客户端一个syn和ack消息，如果仅需要
两次就建立连接，这明显是不正确的，但是如果是三次建立连接，服务端需要等待客户端的确认，客户端并不会发送ack，所以就不会建立连接。


TIME_WAIT和CLOSE_WAIT的区别。
TIME_WAIT位于客户端fin_wait1和fin_wait2之后，他需要等待2msl时长......
CLOSE_WAIT位于服务端接收到fin_wait1发来fin之后
TIME_WAIT状态用来重发可能丢失的ACK报文。 
TIME_WAIT表示主动关闭，CLOSE_WAIT表示被动关闭。


说说你知道的几种HTTP响应码，比如200, 302, 404。
200 ok 一切正常 
302 暂时性转移 重定向
404 页面未找到 

当你用浏览器打开一个链接（如：http://www.javastack.cn）的时候，计算机做了哪些工作步骤。
请求dns服务器解析域名得到请求主机ip，发起tcp建立请求，然后发起http请求，服务器接收http请求并处理，服务器响应，返回html，浏览器对页面进行渲染，断开连接


TCP/IP如何保证可靠性，说说TCP头的结构。
源端口，目的端口，序列号，确认号，首部长度字段，六位标志位，窗口大小，校验和，紧急指针


如何避免浏览器缓存。
请求头中设置Cache-Control:max-age=0，告诉浏览器不要缓存信息
POST请求无法被缓存；动态请求是不能被缓存的


如何理解HTTP协议的无连接和无状态性。
无连接:请求时建连接、请求完释放连接，以尽快将资源释放出来服务其他客户端。但是因为现在网页变得越来越复杂，里面可能嵌入了很多图片，这时候每次访问图片都需要
	  立一次 TCP 连接就显得很低效。Keep-Alive 功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免重新建立连接。
无状态:协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。即我们给服务器发送 HTTP 请求之后，服务器根据请求，会给我们发送数据过来，但是发送完，
	  不会记录任何信息。但是当大量客户端与服务器进行动态交互的 Web 应用程序出现之后，引入了cookie和session。


简述Http请求get和post的区别以及数据包格式。
get请求将参数放置于url后面，post请求将参数放在请求体里，更安全；
get提交的数据最多1024字节，post能传输的数据量很大。


HTTP有哪些method
get、post、put、delete、head、options、trace、patch


简述HTTP请求的报文格式。
请求报文:请求行(请求方法、url、http版本)、请求头(一堆的键值对)、请求体(get方法没有请求体，post方法有请求体)
响应报文:响应行(http版本、状态码、状态码描述符)、响应头(一堆键值对)、响应体(服务器返回给客户端的文本信息)


HTTP的长连接是什么意思。
HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开（不发RST包、不四次握手），等待在同域名下继续用这个通道传输数据
keepalived,不要断开连接，后续如果还有请求，直接在当前连接上请求。


HTTPS的加密方式是什么，讲讲整个加密解密流程。
HTTPS 443端口，HTTP+SSL/TLS
客户端发起https请求。
采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。
传送证书给客户端，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。
客户端解析证书，验证该证书是否有效，如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。
传送加密信息，让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把要传输的内容通过该值进行对称加密。除非知道私钥，不然无法获取内容。


Http和Https的三次握手有什么区别。
当浏览器使用https时，浏览器会先同SSL/TLS进行通信，然后SSL/TLS再同tcp进行通信


REST和RPC的区别
REST是面向资源的（URL表示资源，HTTP动词表示动作），RPC是面向动作的（方法调用）
RPC的编程模型较重量级，REST的编程模型更轻量级
RPC 自定义tcp+json 传输更轻量化， rest http报文会包含很多无用的信息，效率低
对外开放的api采用rest，内部通信采用rpc


Session和cookie的区别。
Session 存放在服务器端的客户端信息，通过sessionID进行标识，客户端每次访问都要带着这个id(通过cookie或者url重写)。会占用服务器性能
Cookie 服务端存放在客户端的信息，不是很安全


数据库知识

数据库隔离级别有哪些，各自的含义是什么，MYSQL默认的隔离级别是是什么。
读未提交，读已提交/不可重复读，可重复读，串行化
mysql默认是可重复读


什么是幻读。
如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，
以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。


MYSQL有哪些存储引擎，各自优缺点。
myisam:拥有较高的插入，查询速度，但不支持事务,使用表级锁，并发性差,主机宕机后，MyISAM 表易损坏，灾难恢复性不佳 
innodb:5.5版本后Mysql的默认数据库，事务型数据库的首选引擎，支持ACID事务，支持行级锁定,灾难恢复性好


高并发下，如何做到安全的修改同一行数据。
使用悲观锁 悲观锁本质是当前只有一个线程执行操作，结束了唤醒其他线程进行处理。 
也可以缓存队列中锁定主键。
加锁分为显式加锁与隐式加锁，上面的写法是显式加锁。mysql在执行insert、update会自动加锁，mysql对select却不会加锁


乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。
乐观锁:认为修改不会发生冲突，只有在提交事务的时候才去检查，如果反正冲突则回滚
悲观锁:认为修改会引起冲突，所以一定要获得排它锁之后才能进行操作
共享锁和排它锁


SQL优化的一般步骤是什么，怎么看执行计划，如何理解其中各个字段的含义。
show status 通过慢查询日志定位哪些是执行效率的sql语句
explain sql 显示了mysql如何使用索引来处理select语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句


数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。
事务A先修改表1后修改表2，事务2先修改表2后修改表1

系统资源不足
进程运行推进的顺序不合适 
资源分配不当等

重启数据库；杀死抢资源的进程


Mysql的索引原理，索引的类型有哪些，如何创建合理的索引，索引如何优化。
最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配
=和in可以乱序
尽量选择区分度高的列作为索引，尽量少重复
尽量的扩展索引，不要新建索引。


聚集索引和非聚集索引的区别。
聚簇索引就是索引和记录紧密在一起。 
非聚簇索引 索引文件和数据文件分开存放，索引文件的叶子页只保存了主键值，要定位记录还要去查找相应的数据块

select for update 是什么含义，会锁表还是锁行或是其他。
为什么要用Btree实现，它是怎么分裂的，什么时候分裂，为什么是平衡的。


数据库的ACID是什么。
A，atomic，原子性，要么都提交，要么都失败，不能一部分成功，一部分失败。 
C，consistent，一致性，事物开始及结束后，数据的一致性约束没有被破坏 
I，isolation，隔离性，并发事物间相互不影响，互不干扰。 
D，durability,持久性，已经提交的事物对数据库所做的更新必须永久保存。即便发生崩溃，也不能被回滚或数据丢失。


某个表有近千万数据，CRUD比较慢，如何优化。


Mysql怎么优化table scan的。
避免在where子句中对字段进行is null判断 
应尽量避免在where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。 
避免在where 子句中使用or 来连接条件 
in 和not in 也要慎用 
Like查询（非左开头） 
使用NUM=@num参数这种 
where 子句中对字段进行表达式操作num/2=XX 
在where子句中对字段进行函数操作


如何写sql能够有效的使用到复合索引。
<、>、between放后面，先执行=

mysql中in 和exists 区别。
mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，
这种说法其实是不准确的。这个是要区分环境的。
如果查询的两个表大小相当，那么用in和exists差别不大。 
A B 两表，A in B 如果B较小，in不错，如果B很大，使用exists
not in 和not exists如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。 
1.EXISTS只返回TRUE或FALSE，不会返回UNKNOWN。
2.IN当遇到包含NULL的情况，那么就会返回UNKNOWN。

数据库自增主键可能的问题。
自增主键会产生表锁；在分库分表时可能会生成重复主键


MVCC的含义，如何实现的。
你做过的项目里遇到分库分表了吗，怎么做的，有用到中间件么，比如sharding jdbc等,他们的原理知道么。
MYSQL的主从延迟怎么解决。


算法

10亿个数字里里面找最小的10个。
有1亿个数字，其中有2个是重复的，快速找到它，时间和空间要最优。
2亿个随机生成的无序整数,找出中间大小的值。
给一个不知道长度的（可能很大）输入字符串，设计一种方案，将重复的字符排重。
遍历二叉树。
有3n+1个数字，其中3n个中是重复的，只有1个是不重复的，怎么找出来。
写一个字符串（如：www.javastack.cn）反转函数。
常用的排序算法，快排，归并、冒泡。 快排的最优时间复杂度，最差复杂度。冒泡排序的 
优化方案。
二分查找的时间复杂度，优势。
一个已经构建好的TreeSet，怎么完成倒排序。
什么是B+树，B-树，列出实际的使用场景。
一个单向链表，删除倒数第N个数据。
200个有序的数组，每个数组里面100个元素，找出top20的元素。
单向链表，查找中间的那个元素。


消息队列

消息队列的使用场景。
消息的重发，补充策略。
如何保证消息的有序性。
用过哪些MQ，和其他mq比较有什么优缺点，MQ的连接是线程安全的吗，你们公司的MQ服务 
架构怎样的。
MQ系统的数据如何保证不丢失。
rabbitmq如何实现集群高可用。
kafka吞吐量高的原因。
kafka 和其他消息队列的区别，kafka 主从同步怎么实现。
利用mq怎么实现最终一致性。
使用kafka有没有遇到什么问题，怎么解决的。
MQ有可能发生重复消费，如何避免，如何做到幂等。
MQ的消息延迟了怎么处理，消息可以设置过期时间么，过期了你们一般怎么处理。


缓存

常见的缓存策略有哪些，如何做到缓存(比如redis)与DB里的数据一致性，你们项目中用到了什么缓存系统，如何设计的。
如何防止缓存击穿和雪崩。
缓存数据过期后的更新如何设计。
redis的list结构相关的操作。
Redis的数据结构都有哪些。
Redis的使用要注意什么，讲讲持久化方式，内存设置，集群的应用和优劣势，淘汰策略等。
redis2和redis3的区别，redis3内部通讯机制。
当前redis集群有哪些玩法，各自优缺点，场景。
Memcache的原理，哪些数据适合放在缓存中。
redis和memcached 的内存管理的区别。
Redis的并发竞争问题如何解决，了解Redis事务的CAS操作吗。
Redis的选举算法和流程是怎样的。
redis的持久化的机制，aof和rdb的区别。
redis的集群怎么同步的数据的。
知道哪些redis的优化操作。
Reids的主从复制机制原理。
Redis的线程模型是什么。
请思考一个方案，设计一个可以控制缓存总体大小的自动适应的本地缓存。
如何看待缓存的使用（本地缓存，集中式缓存），简述本地缓存和集中式缓存和优缺点。 
本地缓存在并发使用时的注意事项。


开源框架知识

简单讲讲tomcat结构，以及其类加载器流程，线程模型等。
tomcat如何调优，涉及哪些参数 。
讲讲Spring加载流程。
Spring AOP的实现原理。
讲讲Spring事务的传播属性。
Spring如何管理事务的。
Spring怎么配置事务（具体说出一些关键的xml 元素）。
说说你对Spring的理解，非单例注入的原理？它的生命周期？循环注入的原理，aop的实现原 
理，说说aop中的几个术语，它们是怎么相互工作的。
Springmvc 中DispatcherServlet初始化过程。
netty的线程模型，netty如何基于reactor模型上实现的。
为什么选择netty。
什么是TCP粘包，拆包。解决方式是什么。
netty的fashwheeltimer的用法，实现原理，是否出现过调用不够准时，怎么解决。
netty的心跳处理在弱网下怎么办。
netty的通讯协议是什么样的。
springmvc用到的注解，作用是什么，原理。
springboot启动机制。


架构设计与分布式

用java自己实现一个LRU。
分布式集群下如何做到唯一序列号。
设计一个秒杀系统，30分钟没付款就自动关闭交易。
如何使用redis和zookeeper实现分布式锁？有什么区别优缺点，会有什么问题，分别适用什么场景。（延伸：如果知道redlock，讲讲他的算法实现，争议在哪里）
如果有人恶意创建非法连接，怎么解决。
分布式事务的原理，优缺点，如何使用分布式事务，2pc 3pc 的区别，解决了哪些问题，还有 
哪些问题没解决，如何解决，你自己项目里涉及到分布式事务是怎么处理的。
什么是一致性hash。
什么是restful，讲讲你理解的restful。
如何设计一个良好的API。
如何设计建立和保持100w的长连接。
解释什么是MESI协议(缓存一致性)。
说说你知道的几种HASH算法，简单的也可以。
什么是paxos算法， 什么是zab协议。
一个在线文档系统，文档可以被编辑，如何防止多人同时对同一份文档进行编辑更新。
线上系统突然变得异常缓慢，你如何查找问题。
说说你平时用到的设计模式。
Dubbo的原理，有看过源码么，数据怎么流转的，怎么实现集群，负载均衡，服务注册 
和发现，重试转发，快速失败的策略是怎样的 。
一次RPC请求的流程是什么。
自己实现过rpc么，原理可以简单讲讲。Rpc要解决什么问题。
异步模式的用途和意义。
编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。
设计一个社交网站中的“私信”功能，要求高并发、可扩展等等。 画一下架构图。
MVC模式，即常见的MVC框架。
聊下曾经参与设计的服务器架构并画图，谈谈遇到的问题，怎么解决的。
应用服务器怎么监控性能，各种方式的区别。
如何设计一套高并发支付方案，架构如何设计。
如何实现负载均衡，有哪些算法可以实现。
Zookeeper的用途，选举的原理是什么。
Zookeeper watch机制原理。
Mybatis的底层实现原理。
请思考一个方案，实现分布式环境下的countDownLatch。
后台系统怎么防止请求重复提交。
描述一个服务从发布到被消费的详细过程。
讲讲你理解的服务治理。
如何做到接口的幂等性。
如何做限流策略，令牌桶和漏斗算法的使用场景。
什么叫数据一致性，你怎么理解数据一致性。
分布式服务调用方，不依赖服务提供方的话，怎么处理服务方挂掉后，大量无效资源请求 
的浪费，如果只是服务提供方吞吐不高的时候该怎么做，如果服务挂了，那么一会重启，该怎 
么做到最小的资源浪费，流量半开的实现机制是什么。
dubbo的泛化调用怎么实现的，如果是你，你会怎么做。
远程调用会有超时现象，如果做到优雅的控制，JDK自带的超时机制有哪些，怎么实现的。


搜索

elasticsearch了解多少，说说你们公司es的集群架构，索引数据大小，分片有多少，以及一些调优手段。elasticsearch的倒排索引是什么。
elasticsearch 索引数据多了怎么办，如何调优，部署。
elasticsearch是如何实现master选举的。
详细描述一下Elasticsearch索引文档的过程。
详细描述一下Elasticsearch搜索的过程。
Elasticsearch在部署时，对Linux的设置有哪些优化方法？
lucence内部结构是什么。